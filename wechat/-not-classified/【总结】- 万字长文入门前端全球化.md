> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/MingzWHJhVKjN7bWgXHTvA)

许多国内企业正积极开拓国际市场，如 Shopee、阿里的 Lazada、字节的 TikTok、拼多多海外版 Temu、以及服装快消领域的 Shein 等。当国内市场存量业务达到峰值预期时，海外业务成为各公司未来收入增长的主要动力，因此，国际化已成为越来越重要的职业发展方向。

国内 IT 企业收入天花板: **「10 亿 X2 元 X365 天 = 7300 亿元」**，也就是 10 亿人口，企业每天赚取用户 2 元，保持 365 天，就是单业务增长的营收天花板 (大部分业务赚不到 2 元，用户量也没到 10 亿)。比如视频如果 60 元一个月那会员营收天花板就可以这么预估. 甚至比这个还低, 毕竟用户会流失, 拉新也要成本, 运营成本是在递增的。

国际化不仅仅是多语言文案适配这么简单，而是一全套的工程化解决方案。笔者觉得更重要的是**「从业人员需要具备全球视野，对多元文化有包容心和敬畏心理，同时知识面要求也较高」**。比如，了解 SEA、US、UK 等常见地区的简写，尊重伊斯兰教的斋月节等习俗。对于服务全球用户的产品来说，对应产品的要求更加复杂，多样性体现在不同的文化习俗差异上，其实即便在庞大的中国内部也存在南北差异。了解的越多越发现这个世界的 “多样性”。

概念说明
====

苹果键盘怎么卖多国?
----------

苹果键盘有很多型号不同型号的布局不一样 https://www.apple.com/shop/product/MK2A3J/A/magic-keyboard-japanese

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibG4aFhQjbLmTdaqPO7LK16XMoy6x2bdUpjhibvxKjWnWpZulTZLibmubzg/640?wx_fmt=png&from=appmsg)apple-keyboard

那如何模仿苹果造一把可以卖到世界各地的键盘? 

1.  电路板等硬件配件统一生产
    
2.  制定三种布局方案 (Arabic, Russian, Ukrainian 归为一种, Chinese (Zhuyin) 和 Korean 为一种, Japanese 为一种)，单独开孔
    
3.  键帽印刷不同语言的文案
    
4.  MacOS 开发语言输入软件适配不同键盘的语言输入
    

其中 2，3，4 都是为产品的全球化服务

全球化 = 国际化 i18n + 本地化 l10n
-------------------------

https://en.wikipedia.org/wiki/Internationalization_and_localization

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGCwY6fttGX8roTnMicpmClLEenyL4UAsFRNDF4icDBO59IXqTBm6em9MQ/640?wx_fmt=png&from=appmsg)globalization

1.  产品设计和开发部署需要需要考虑国际化 i18n
    

1.  多语言
    
2.  多布局，如阿拉伯语的 RTL
    
3.  多货币
    
4.  全球多地区多机房部署 (离用户越近服务体验越好，数据物理存储隔离符合各个国家数据安全要求)
    

3.  产品本地化 L10N 是国际化后的**「可选」**流程，需要引入**「本地化团队」**转化和质量验收，再投入本地化市场
    

1.  本地化步骤是可选的，如英美产品 UI，语言基本一致可互通，本地化投入少
    
2.  中文地区等有简体繁体，不同地区用语习惯不一样，也要特别兼顾，如香港的粤语和广州的粤语，在一些用词有区别，像吸管 (广州)－饮筒 (香港)，你可以看 https://www.zhihu.com/question/20663233
    
3.  阿拉伯语，希伯来语等地区 RTL 的阅读习惯，对产品改动较大需要特殊适配
    

国际化
---

产品面向全球用户，需要做语言适配，针对不同国家地区的用户提供对应语言的版本。本质是**「文本替换」**，也要考虑文本阅读方向，比如阿拉伯语和希伯来语是从右到左。

可以看下 Apple 的做法，对不同国家地区提供不同服务

*   Apple US 对应链接 https://www.apple.com/
    
*   Apple CN  对应链接 https://www.apple.com.cn/
    
*   Apple HK 对应链接 https://www.apple.com/hk/en/
    

常见地区语言对应关系可以看 ISO 3166-1(https://baike.baidu.com/item/ISO%203166-1/5269555?fr=ge_ala)

Intl
----

MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl

浏览器中的 `Intl` 是一个内置的 JavaScript 对象，用于国际化（Internationalization）支持。它提供了处理日期、时间、数字格式化以及货币和语言的能力，以便网站能够根据用户的语言和地区习惯来显示内容。在 JavaScript 中，您可以使用 `Intl` 对象来执行以下操作：

1.  格式化日期和时间：使用 `Intl.DateTimeFormat` 对象可以格式化日期和时间，并根据用户的地区偏好显示日期和时间。
    
2.  格式化数字：使用 `Intl.NumberFormat` 对象可以格式化数字，并根据用户的地区偏好显示数字。
    
3.  处理货币：使用 `Intl.NumberFormat` 对象结合指定的货币代码可以格式化货币，并根据用户的地区偏好显示货币。
    
4.  语言和区域设置信息：使用 `Intl.getCanonicalLocales` 方法可以获取支持的语言和区域设置信息。关于标点符号，通常在国际化的环境下，标点符号使用英文是比较常见的做法，因为英文标点符号在全球范围内都有通用性，可以避免因为地域差异而引起的误解。在 `Intl` 对象中，一般不会直接涉及到标点符号的处理，而是主要用于处理日期、时间、数字和货币等格式化需求。
    

前置知识
====

语言标识
----

全地球有 N 个民族，有的民族有自己的语言, 有的民族用其他国家民族传递过来的语言, 融化吸收然后发展自己的文字。

按照 ISO 标准 (https://zh.m.wikipedia.org/wiki/ISO_639-1)，语言可以用大类 + 小类表示, 比如**「zh」**就是汉语，是一个大类，而**「zh-CN」**就是简体中文的缩写, 新加坡华人众多久了就有**「zh-SG」**, 表示的是新加坡使用的中文，其次还有**「zh-HK/zh-TW 和 zh-Hant/zh-Hans」**等等

语言声明是三段式结构 `[language]-[script]-[region]` , 如 zh-Hans-CN 表示中国地区简体中文, zh-Hant 表示所有中文繁体

Language Code Table(http://www.lingoes.net/zh/translator/langcode.htm)

一起来看下苹果官网是如何适配多国语言的

*   澳门 apple https://www.apple.com/mo/
    
*   香港 apple
    

*   英文 https://www.apple.com/hk/en/
    
*   中文 https://www.apple.com/hk/
    

*   中国大陆地区 apple https://www.apple.com.cn/
    
*   台湾 apple https://www.apple.com/tw/
    
*   新加坡 apple https://www.apple.com/sg/
    
*   日本 apple https://www.apple.com/jp/
    

可以看到有的是根域名下通过 ISO 地区的 path 比如 **/hk/** 这样来区分的，有的是直接换域名，比如中国大陆地区

文字阅读顺序
------

按照普通的中文和英文顺序，都是 LTR，上到下，都是世界范围通用的

而 ar 阿拉伯语, ur 乌都语, he 希伯来语都是特殊的从右到左, 即 RTL 的一般会通过标签的 dir 属性标识, 比如下面的解释 HTML dir Attribute(https://www.w3schools.com/tags/att_global_dir.asp)

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGSJ7aiahsolKVuiaBOdJElMrIolibQt0Hg8bDvgwIayCJgFibYkVhlHWKkA/640?wx_fmt=png&from=appmsg)HEBREW 是指希伯来语，这是一种在以色列广泛使用的语言，也是犹太教的宗教经典文本的原始语言。它属于阿夫罗亚细亚语系，有着悠久的历史和文化价值。**「希伯来语有其独特的书写系统，从右向左书写。」**上图的概念很少人普及, 因为非国际化产品不需要多语言, 做需要支持海外业务和全球应用的同学可以多了解下. 传统的英文, 中文简体, 拉丁文等都是上图 LATIN 的阅读顺序, 如果用上**「top, 下 bottom, 左 left, 右 right」**代表我们的习惯, 也就是**「Z」**这样的顺序. 即行到行是从上到下的顺序, 行内阅读顺序是从左到右.

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGwaN7uxTmNE13rBCyCE977EtGZrqVYTckribTGACcPLqxDBj5tjmZ1TQ/640?wx_fmt=png&from=appmsg)文档流和阅读顺序

即 left→right, top→bottom 的顺序，有主次分别，left→right 的优先级高于 top→bottom

而 Web 标准对其定义是下面这样的

*   left = inline-start
    
*   right = inline-end
    
*   top = block-start
    
*   bottom = block-end
    

讲个笑话, 古代书籍就是按照 `writing-mode: vertical-rl` 排版的

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGic0qCUKSP3962K0unhxKz55ibl06oxic3ynCB6IOhDiaPzHKicGrju5A2ibQ/640?wx_fmt=png&from=appmsg)joke

布局
==

content-flows
-------------

比如 `margin: left` 或者 `text-align: left` 在多语言场景都是不合适的，你的左右不是其他人的左右。

而应该用 `margin-inline-start` 和 `text-align: start` 替代，即 inline 轴和 block 轴

```
// 下面两两相等，请抛弃left/right/top/bottom等属性// https://web.dev/learn/css/logical-properties/#terminologymargin-left: 1pxmargin-inline-start: 1pxmargin-right: 1pxmargin-inline-end: 1pxmargin-top: 1pxmargin-block-start: 1pxmargin-bottom: 1pxmargin-block-end: 1pxtext-align: lefttext-align: starttext-align: righttext-align: endmax-width: 100pxmax-inline-width: 100pxmax-inline-size: 150pxmax-height: 100pxmax-block-width: 100pxpadding-left: 1pxpadding-inline-start: 1pxpadding-top: 1pxpadding-block-start: 1pxtop: 0.2em;inset-block-start: 0.2em;bottom: 0.2em;inset-block-end: 0.2em;left: 2px;inset-inline-start: 2px;right: 2px;inset-inline-end: 2px;border-bottom: 1px solid red;border-block-end: 1px solid red;border-bottom-right-radius: 1em;border-end-end-radius: 1em;height: 160px;block-size: 160px;width: 160px;inline-size: 160px;
```

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGZEtWdqBNMEAwMnQrpljGl5y2TLPhicqvHSTRZV25UIkMnUtgmZpviaBw/640?wx_fmt=png&from=appmsg)

也可以看下面的例子

*   https://codepen.io/web-dot-dev/pen/gOxXOLK
    
*   https://codepen.io/web-dot-dev/pen/mdMqdOx
    

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGveOtlvcDsI8SNQr2oO2WShTuqVDlScZh4PBEfASRDSTXbRbhhubKNA/640?wx_fmt=png&from=appmsg)

如上两个例子通过 margin-inline-start 等属性，再在 html 元素上添加 `dir: rtl` 就可以实现多语言的阅读顺序兼容

由此, 常见的布局也会更新为以下形式，常见的物理盒模型用于尺寸计算, 逻辑盒模型用于国际化处理

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGwHbURmOKZkgv2pP02xQibzickUbicYG3UUgqa4QasCwwd5MXGlUBl6S0A/640?wx_fmt=png&from=appmsg)盒子模型

writing mode 决定 content-flows
-----------------------------

上面写了文档有 inline and block flow，对应 english 的 left 和 right，top 和 bottom。而 `writing-mode` 可以修改 content-flows，比如下面的值

```
/* 关键值 */writing-mode: horizontal-tb;writing-mode: vertical-rl;writing-mode: vertical-lr;
```

可以这么理解 `writing-mode: horizontal-tb` ，前面的 horizontal/vertical 是指的 inline 轴的方向，

https://codepen.io/manfredhu/pen/xxWdpaK

vi 和 vb
-------

视口宽高 viewport 在这里也有特殊含义. 比如宽高 vw 和 vh 也被取代，用 **vi(viewport inline) 和 vb(viewport block)** 替代

```
1%宽度=1vw=1vi 1%高度=1vh=1vb
```

JS 的 scrollLeft
---------------

DOM 的 API 可以通过**「Element.scrollLeft」**获取到元素滚动的距离，下图是一个实际例子

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGUrTYLfaG3bibZicNKutmmEkrtpQKy7FbN1PaSO5bp6K2OjeaRJn2icjZg/640?wx_fmt=png&from=appmsg)scrollLeft 的 rtl

这里在最后做了一个遮罩（绿色边框区域），内部蓝色部分类似一个走马灯，通过 overflow:hidden 将蓝色高亮部分超出的区域遮住

当蓝色部分滚动到最后，绿色遮罩隐藏，达到一个遮盖，滚动到最后消失的效果，代码如下

```
const ref = document.querySelector('.tiktok-table__container') // 父节点，蓝色区域const ref2 = document.querySelector('.tiktok-table__container > table') // 子节点，表格区域const bufferWidth = 30 // 留一点buffer空间if (ref && ref2 && ref.clientWidth + ref.scrollLeft >= ref2.clientWidth - bufferWidth) {  // 滚动到最后隐藏绿色遮罩  setTableRightMask(false)} else {  setTableRightMask(true)}
```

但是在 RTL 下，神奇的事情就发生了，scrollLeft 居然是负数

这是因为 RTL 的实现是通过 HTML 标签增加属性 `dir="rtl”` 实现的，会将文档完全翻转过来，所以 scrollLeft 就会是负数。因为此时 (0, 0) 这个原点已经是表格右边了

![](https://mmbiz.qpic.cn/mmbiz_gif/lP9iauFI73ziccTIqicw4bibX7y6Gv8L8ycPCrsCd7b2gdv2icwHg6lTIJGia5FlAh6dKJ9phdZScpPd8P12kKlvbbmA/640?wx_fmt=gif&from=appmsg)

解决方法也很简单，取绝对值呗，这样就忽略了方向的影响

locale
======

根据 ISO 标准对全球国家地区进行划分 https://en.wikipedia.org/wiki/ISO_3166-2. 如 "US" 表示美国，"CN" 表示中国. 还有常见的如**「zh-CN, en-US, en-GB 等」**

*   CN 是国家地区码, 根据国际标准 ISO 3166-1 规定的国家和地区代码。ISO 3166-1 是用于标识国家和地区的国际标准，每个国家或地区都有一个唯一的两字母代码。"CN" 代表中华人民共和国（People's Republic of China），即中国
    
*   zh-CN 是语言地区码, 它通常用于表示中文（"zh" 代表中文）以及特定的地区或国家，这里 "CN" 代表中国。"zh" 代表中文，这是根据国际标准 ISO 639-1 规定的语言代码。ISO 639-1 是用于标识语言的国际标准，每个语言都有一个唯一的两字母代码。"zh" 代表中文，但不区分中文的不同方言，如普通话和粤语。
    
*   zh-Hans-CN 表示中国大陆地区的简体中文，还有 "zh-Hans-SG" 可用于表示新加坡的官方简化中文，"zh-Hans-TW" 可用于表示台湾的官方简化中文
    

Intl. Locale
------------

举个🌰说下 Intl API 对于 locale 的定义

```
const korean = new Intl.Locale('ko', {  script: 'Kore',  region: 'KR',  hourCycle: 'h23',  calendar: 'gregory',});const japanese = new Intl.Locale('ja-Jpan-JP-u-ca-japanese-hc-h12');console.log(korean.baseName, japanese.baseName);// Expected output: "ko-Kore-KR" "ja-Jpan-JP"
```

可以看到 Intl. Locale 就是把传入的字符串拆解为 `[language]-[script]-[region]` 的组成.

*   ja：代表语言代码，表示日语（Japanese）
    
*   Jpan：代表脚本代码，表示使用日语文字（Japanese script）
    
*   JP：代表地区代码，表示日本（Japan） 这里的 `u-ca-japanese` 表示 unicode calendar 也就是日历格式 (日本日历与众不同), hc 表示 hourCycle 这里 hc-h12 表示 12 小时制. `u-ca-japanese` 和 `hc-h12` 的顺序无关, 也就是说如下两种用法完全等价
    

```
const japanese = new Intl.Locale('ja-Jpan-JP-u-ca-japanese-hc-h12');const japanese2 = new Intl.Locale('ja-Jpan-JP-u-hc-h12-ca-japanese');
```

`-u` (unicode) 可以理解为额外扩展插件, 插件系统支持以下扩展. 如上使用 calendar 扩展和 hourCycle 扩展

<table><thead><tr><th><section><br></section></th><th><section><br></section></th></tr></thead><tbody><tr><td><section>calendar</section></td><td><section>ca (extension)</section></td></tr><tr><td><section>caseFirst</section></td><td><section>kf (extension)</section></td></tr><tr><td><section>collation</section></td><td><section>co (extension)</section></td></tr><tr><td><section>hourCycle</section></td><td><section>hc (extension)</section></td></tr><tr><td><section>numberingSystem</section></td><td><section>nu (extension)</section></td></tr><tr><td><section>numeric</section></td><td><section>kn (extension)</section></td></tr></tbody></table>

*   calendar：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/calendar)
    
*   caseFirst：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/caseFirst)
    
*   collation：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/collation)
    
*   hourCycle：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/hourCycle)
    
*   numberingSystem：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/numberingSystem)
    
*   numeric：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/numeric)
    

语言声明
----

```
<html lang="en-US"><!-- 说明页面语言是美式英文 --><p>I felt some <span lang="de">schadenfreude</span>.</p> <!-- lang不是只有html标签才有, 其他标签也可以添加 --><a href="/path/to/german/version" hreflang="de" lang="de">Deutsche Version</a> <!-- a标签上可以用lang表示显示的文本的语言, 也可以用hreflang表示跳转页面的语言 -->
```

language 设置
-----------

语言属性通常代表语言标识符的主要部分。它标识了用于表达语言的基本信息。例如，在 BCP 47 标准中，语言标识符通常包含了语言的主要代码部分，例如 "en" 代表英语，"es" 代表西班牙语。

```
const locales = ['en', 'de', 'ja'];const displayNames = new Intl.DisplayNames('en-US', { type: 'language' });locales.forEach(locale => console.log(displayNames.of(locale)));// English// German// Japanese
```

如果已经有如上代码, 再进一步给这些内容添加样式是非常简单的, 我们可以使用 CSS 的选择器. 如 `[lang|="fr"]` 或者 `:lang(fr)`

`[lang|="fr"]` 选择属性 `lang=fr` 或者 lang 属性以 fr 开头的元素, 如 `lang=fr-CA`

script 设置
---------

脚本属性是语言标识符的可选部分，表示使用的书写系统或文字的风格。这是一个辅助信息，用于更精确地表示特定语言的书写习惯。例如，"Hans" 代表简体中文，"Latn" 代表拉丁文。

script 的 of 支持传入 BCP47 规范的二字码 (https://en.wikipedia.org/wiki/IETF_language_tag), 如 zh

```
const scriptNames = new Intl.DisplayNames('en-US', { type: 'script' });console.log(scriptNames.of('Hans')); // output：Simplifiedconsole.log(scriptNames.of('Hant')); // output：Traditionalconsole.log(scriptNames.of('Latn')); // output：Latinconst scriptNames = new Intl.DisplayNames('zh-CN', { type: 'script' });console.log(scriptNames.of('Hans')); // output：简体console.log(scriptNames.of('Hant')); // output：繁体console.log(scriptNames.of('Latn')); // output：拉丁文
```

region 设置
---------

region  的 of 支持传入 https://en.wikipedia.org/wiki/ISO_3166-2 里的国家二字码

```
const regionNamesInEnglish = new Intl.DisplayNames(['en'], { type: 'region' });const regionNamesInTraditionalChinese = new Intl.DisplayNames(['zh-Hant'], { type: 'region' });console.log(regionNamesInEnglish.of('US'));// Expected output: "United States"console.log(regionNamesInTraditionalChinese.of('US'));// Expected output: "美國"
```

文本
==

阅读顺序声明
------

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGiaSibo796IuhbLyYZTcc9btsgnm29lgNPFzEMtFVojlhLYLpyC4r1sMA/640?wx_fmt=png&from=appmsg)文本的阅读顺序声明

### html 标签 dir 属性

可以通过 html 标签的 dir 属性设置

```
<html dir="ltr"><html dir="rtl">
```

### css 属性 writing-mode(https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode)

```
writing-mode: horizontal-tb;writing-mode: vertical-lr;writing-mode: vertical-rl;
```

文本行的布局方向, 以及块的排列方向。如果想作用在整个文档需要设置 html 标签, 则全局生效

**「第一个属性 horizontal/vertical 指的是行块的排列, 第二个属性则是指文本内容的流向 (content flows)」**

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGAvYBfOyiaAgGCSQuzmUFgCtPFJ1oPSIuK1Skp3ia3p9UQPfMGSY43NXg/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibG1eGzTTMde3udpia9lZgIZTlbjibjpzlc2eBV6GlnQvEbhIMlGVTEdMfw/640?wx_fmt=png&from=appmsg)

翻转
--

形如 **「?」** 这种符号类，在多语言下是不一样的

比如 ar 阿拉伯语和 ur 乌尔都斯语问号是 RTL 的，即 **「؟」**(https://zh.m.wiktionary.org/wiki/%D8%9F) 是 OK 的

而 he 希伯来语是 LTR 的，即 **「?」** 是 OK 的

是不是很神奇？一个问号也能玩出花来

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGn4JSndmCZ2qNZYOvhYmyPuic6TcjqBWAb1wEtlNuR8TLUl311xEpvdQ/640?wx_fmt=png&from=appmsg)线索管理页 - 英文和阿拉伯语

常见的需要 RTL 的语言有下面这些

1.  **「阿拉伯语（AR）」**：阿拉伯语是使用 RTL 方向书写的最著名的语言之一。它是中东和北非地区的主要语言，以及伊斯兰教的官方语言。
    
2.  **「希伯来语（HE）」**：希伯来语是犹太人的宗教和文化语言，以及以色列的官方语言。它也是一个使用 RTL 方向书写的语言。
    
3.  **「波斯语（FA）」**：波斯语，也称为法尔西语，是伊朗的官方语言，以及一些中东国家的官方或辅助语言。它使用 RTL 方向书写。
    
4.  **「乌尔都语（UR）」**：乌尔都语是巴基斯坦和印度的官方语言之一，以及一种使用 RTL 方向书写的语言。
    
5.  **「帕斯图语（PS）」**：帕斯图语是阿富汗的官方语言之一，也是使用 RTL 方向书写的语言。
    

```
const rtlLangs = [    'ar', // 阿拉伯语    'ur', // 巴基斯坦    'he', // 以色列    'he-IL', // 希伯来语(以色列)    'fa-IR', // 波斯语(伊朗)    'ps' // 帕斯图语];
```

多语言文案
-----

l10n 本地化的一个比较多工作量的部分是文本的翻译, 一种文本到 N 种文本的翻译需要引入本地化团队. 技术实现上选择也很多

### 程序打包嵌入文案

通过 `key: text` 映射, 比如 `t('key')` 最后程序跑出来就是 text 文案, 这种方式不会依赖其他东西, 跟普通网页一样内容都是 CDN 文件. 缺点是文案做为静态资源需要用户额外获取, 如果处理不好替换错误就展示 `key` 内容而不是

*   vue i18n：https://kazupon.github.io/vue-i18n/zh/started.html#html
    
*   react i18n：https://react.i18next.com
    

以下例子以 Vue 为例, 配置如**「en.json, fr.json」**等等的静态配置文案, 打包嵌入 CDN 的 JS 文件里

Vue i18n example：https://codesandbox.io/p/sandbox/o7n6pkpwoy?file=%2Fstore.js%3A10%2C14

### 接口获取

程序运行时通过接口拿文案，可以通过 html 标签添加 query 参数 lang=xxx 标记页面语言, 或者 cookie 标记语言选择

### 实时翻译替换

加载翻译的脚本, 在切换语言的时候替换掉加载的文本。好处是加载的脚本是当前语言所需要的, 不会有其他语言的冗余. 缺点是依赖一个翻译服务, 如果翻译服务宕机了网页就不能正常访问了

```
User -> gateway -> SSR -> i18n cache -> read-time translation services(实时翻译服务)
```

占位符与单复数处理 - ICU 语法
------------------

DevPal - ICU message editor：https://devpal.co/icu-message-editor/?data=I%20have%20%7Bnum%2C%20plural%2C%20one%7B%7Bnumber%7D%20%23%20apple%7D%20other%7B%23%20apples%7D%7D%2Cbut%20it%27s%20too%20small%0A

ICU 语法即通用的有 if-else 逻辑的 DSL，如下 DSL 可以根据传入的值换取不同的表示，常用于国际化业务

```
I have {num, plural, one{{number} # apple} other{# apples}},but it's too small
```

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGAIP2qCeicJRTd5kXceqRbHXaTfxArUSPdibhcC1o0n1hysJdqHV06xQw/640?wx_fmt=png&from=appmsg)

Intl. Segmenter 分段器
-------------------

如果你用过 vim 一定知道 w(word) 可以移动到下个单词, 英文里把文本分为单词、句子和段落，同理中文也是

*   **「`w`」** word 一个单词
    
*   **「`s`」** sentence 一个句子
    
*   **「`p`」** paragraph 一个段落
    

```
const segmenter = new Intl.Segmenter('en-US', { granularity: 'word' });const text = 'This is a sample text for demonstration purposes.';// 使用 Segmenter 对文本进行分割const segments = [...segmenter.segment(text)];console.log(segments);// 0: {segment: 'This', index: 0, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 1: {segment: ' ', index: 4, input: 'This is a sample text for demonstration purposes.', isWordLike: false}// 2: {segment: 'is', index: 5, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 3: {segment: ' ', index: 7, input: 'This is a sample text for demonstration purposes.', isWordLike: false}// 4: {segment: 'a', index: 8, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 5: {segment: ' ', index: 9, input: 'This is a sample text for demonstration purposes.', isWordLike: false}// 6: {segment: 'sample', index: 10, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 7: {segment: ' ', index: 16, input: 'This is a sample text for demonstration purposes.', isWordLike: false}// 8: {segment: 'text', index: 17, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 9: {segment: ' ', index: 21, input: 'This is a sample text for demonstration purposes.', isWordLike: false}// 10: {segment: 'for', index: 22, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 11: {segment: ' ', index: 25, input: 'This is a sample text for demonstration purposes.', isWordLike: false}// 12: {segment: 'demonstration', index: 26, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 13: {segment: ' ', index: 39, input: 'This is a sample text for demonstration purposes.', isWordLike: false}// 14: {segment: 'purposes', index: 40, input: 'This is a sample text for demonstration purposes.', isWordLike: true}// 15: {segment: '.', index: 48, input: 'This is a sample text for demonstration purposes.', isWordLike: false}
```

Intl. Segmenter 分段器可以把句子, 段落, 文章等按照配置切割为不同的 segment 数组, 结构类似正则, 有 segment 属性

再举个例子, 中文语境下**「真的」**其实是一个词

```
// 创建分段器，指定语言环境和分段类型为'word'const segmenter = new Intl.Segmenter(['en', 'zh'], { granularity: 'word' });// 要分割的字符串const text = 'Hello世界Hello world';// 使用分段器分割字符串const segments = segmenter.segment(text);// 遍历并打印每个分段的结果for (const segment of segments) {    console.log(`Segment: ${segment.segment}, Index: ${segment.index}, IsWordLike: ${segment.isWordLike}`);}// Segment: Hello, Index: 0, IsWordLike: true// Segment: 世界, Index: 5, IsWordLike: true// Segment: Hello, Index: 7, IsWordLike: true// Segment:  , Index: 12, IsWordLike: false// Segment: world, Index: 13, IsWordLike: true
```

```
const str = "我真的很强, 强哥的强";const segmenterJa = new Intl.Segmenter("zh-CN", { granularity: "word" });const segments = segmenterJa.segment(str);console.log(Array.from(segments));// 0: {segment: '我', index: 0, input: '我真的很强, 强哥的强', isWordLike: true}// 1: {segment: '真的', index: 1, input: '我真的很强, 强哥的强', isWordLike: true}// 2: {segment: '很', index: 3, input: '我真的很强, 强哥的强', isWordLike: true}// 3: {segment: '强', index: 4, input: '我真的很强, 强哥的强', isWordLike: true}// 4: {segment: ',', index: 5, input: '我真的很强, 强哥的强', isWordLike: false}// 5: {segment: ' ', index: 6, input: '我真的很强, 强哥的强', isWordLike: false}// 6: {segment: '强', index: 7, input: '我真的很强, 强哥的强', isWordLike: true}// 7: {segment: '哥', index: 8, input: '我真的很强, 强哥的强', isWordLike: true}// 8: {segment: '的', index: 9, input: '我真的很强, 强哥的强', isWordLike: true}// 9: {segment: '强', index: 10, input: '我真的很强, 强哥的强', isWordLike: true}
```

时间 & 时区
=======

国际化会有时区划分问题, 时区产生于太阳下地球自转导致的昼夜交替. 而全球不同国家地区当地时间与 UTC 时间是不一致的. 全球大部分人都可以说自己早上起床, 晚上睡觉. 上下文是通的. 但是这个早上的时间根据 UTC 来定义是不一样的

GMT 和 UTC
---------

*   **GTM = Greenwich Mean Time**，GTM 是英国格林威治时间，但是与太阳时偏差较大，已成为历史不再作为标准
    
*   UTC = **「协调世界时（UTC: Coordinated Universal Time）- 由原子钟提供」**
    

时间的往事 -- 记一次与夏令时的斗智斗勇：https://jiangyixiong.top/2021/05/25/%E6%97%B6%E9%97%B4%E7%9A%84%E5%BE%80%E4%BA%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8E%E5%A4%8F%E4%BB%A4%E6%97%B6%E7%9A%84%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87

GMT 标准时间 全球时区查询：https://time.artjoey.com/cn

通过 NTP 协议 (https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%99%82%E9%96%93%E5%8D%94%E5%AE%9A), 让计算机在全球网络里保持时间一致

**「Offset 与 Timezone」**
-----------------------

*   Offset 即偏移量，比如中国在东八区，Offset 是`+08:00:00`
    
*   而东八区不止包括中国时间，而是一组东西经符合一个区域的集合，比如
    

```
东八区 = {CST（中国标准时）,SGT（新加坡时间）,AWST（澳洲西部标准时）... }
```

### 如何获取当前用户的时区信息

```
// 所在地区的时区标识符, 如 America/New_Yorkconst timeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;console.log("用户时区偏移：" + timeZone); // 用户时区偏移：Asia/Shanghai// 获取本地时间与UTC时间偏移值,最小单位是分钟. 如"-480", 表示-8小时. 其中正负表示UTC前后, 如美国东部时间是UTC-5, 中国北京时间是UTC+8const date = new Date();const timeZoneOffset = date.getTimezoneOffset();console.log("时区偏移：" + timeZoneOffset); // 时区偏移：-480
```

Intl 是新的浏览器 API, 与 Math 类似是全局静态对象, 专门用于处理国际化和本地化业务. 其下的 DateTimeFormat 可以处理时间相关国际化问题

DST
---

DST (Daylight saving time)，日光节约时，夏令时 / 冬令时等等名称。**「它会在每年春天的某一天将时钟向后拨一小时，又在秋天的某一天将时钟向前拨动一个小时。」**非国际化业务很少遇到这个情况，主要因为**「中国不实行夏令时 / 冬令时。」**

*   为什么要实行夏令时？一战时德国率先实行，将每年夏天增加 1h，冬天较少 1h
    
*   会产生什么现象？因为是行政约定，每年都可以自由选择某天某时进入夏令时，各国自由发布。IANA 会存储 (https://www.iana.org/time-zones) 同步各国 DST，计算机每小时同步时间后会在某一秒发生**「突变」**，比如 1:59 到 2 点的时候突变会 1:00
    
*   计算机如何表示时间？计算机都有一个 unixTime，它表示当前时间距离世界标准时的 1970 年 1 月 1 日 0 点 0 分 0 秒的毫秒数，是一个绝对值，也就是 UTC 时间
    
*   但是不同地区设备会根据本地有一个格式化，将 UTC 时间转化为本地时间，比如中国在东八区
    

```
2021-03-14 01:59:59 GMT-08:00（太平洋标准时间，PST）2021-03-14T01:59:59.000-08:00（ISO格式表示）2021-03-14T09:59:59.000Z（转换为UTC时间并以ISO格式表示）// 下一秒时间突变2021-03-14 03:00:00 GMT-07:00（太平洋夏令时间，PDT）2021-03-14T03:00:00.000-07:00（ISO格式表示）2021-03-14T10:00:00.000Z（转换为UTC时间并以ISO格式表示）
```

```
// 原始时间字符串const timeString = "2021-03-14T09:59:59.000Z";// 将时间字符串转换为 Date 对象const date = new Date(timeString);const pstOutput = date.toLocaleString("en-US", { timeZone: "America/Los_Angeles", hour12: false });console.log(pstOutput); // 3/14/2021, 01:59:59// 获取时间戳const timestamp = date.getTime();// 增加1秒const newTimestamp = timestamp + 1000;// 创建新的 Date 对象并格式化为 PDT 时间const newDate = new Date(newTimestamp);const pdtOutput = newDate.toLocaleString("en-US", { timeZone: "America/Los_Angeles", hour12: false });console.log(pdtOutput); // 3/14/2021, 03:00:00
```

时间处理
----

### Dayjs 插件

dayjs: https://day.js.org/docs/zh-CN/i18n/i18n

国际化支持 https://github.com/iamkun/dayjs/tree/dev/src/locale

原理：通过拉取多语言文案输出不同的 formated 日期时间字符串

可以看这个 demo

Days of the week：https://codesandbox.io/s/dayjs-dynamic-locale0import-forked-wnk2zq?file=/src/index.js

因我本地系统设置了每周第一天为星期日

### Intl API

```
const date = new Date();const formattedDate = new Intl.DateTimeFormat('en-US').format(date);console.log(formattedDate); // 10/29/2023const formattedDate = new Intl.DateTimeFormat('zh-CN').format(date);console.log(formattedDate); // 2023/10/29
```

### 本地时间输出

```
// 创建 DateTimeFormat 对象，并指定语言和地区const dateFormatterCN = new Intl.DateTimeFormat('zh-CN', {  year: 'numeric',  month: 'long', // 使用完整的月份名称  day: 'numeric',});console.log(dateFormatterCN.format(new Date('2024-04-28'))); // 2024年4月28日const dateFormatterUS = new Intl.DateTimeFormat('en-US', {  year: 'numeric',  month: 'long', // 使用完整的月份名称  day: 'numeric',});console.log(dateFormatterUS.format(new Date('2024-04-28'))); // April 28, 2024
```

**「Intl. RelativeTimeFormat」** 相对时间
-----------------------------------

**「`Intl.RelativeTimeFormat`」** 是 JavaScript 中的国际化 API，用于格式化相对时间，例如 “1 小时前” 或“2 天后”。这个 API 可以根据不同的语言和地区设置，以自然语言的方式呈现相对时间，使应用程序能够更好地适应多语言环境。

```
const rtf1 = new Intl.RelativeTimeFormat('zh', { style: 'short' });console.log(rtf1.format(3, 'quarter'));// Expected output: "3个季度后"console.log(rtf1.format(-1, 'day'));// Expected output: "1天前"const rtf2 = new Intl.RelativeTimeFormat('jp', { numeric: 'auto' });console.log(rtf2.format(2, 'day'));// Expected output: "后天"
```

我们知道中文语境是一万以上可以缩写为 1 万, 或者是 1 0000. 也就是 4 位数字. 比如 1 2345 6789 或者 1’2345’6789(’是万位分隔符) 可以一眼看出来是一亿两千三百四十五万六千七百八十九. 而如果是 123, 456, 789 可能很多人会愣很久重新数才知道是多少. 但是现在很多银行 APP 都在推跟欧美一样的属于后者的千位分隔符. 可以看这篇讨论觉得写的在理

设计产品时，你是如何掉入从众的陷阱中的？– 人人都是产品经理：https://www.woshipm.com/pd/1500589.html)

类似以上例子可以再看下面的举例, 可以发现在德语和法语下, 千分位分隔符分别是`.`和 （空格）

```
const number = 1234567.89;const formattedNumber = new Intl.NumberFormat('zh-CN').format(number);console.log(formattedNumber); // 1,234,567.89const number = 1234567.89;const formattedNumber = new Intl.NumberFormat('en-US').format(number);console.log(formattedNumber); // 1,234,567.89const number = 1234567.89;const formattedNumber = new Intl.NumberFormat('de-DE').format(number);console.log(formattedNumber); // 1.234.567,89const number = 1234567.89;const formattedNumber = new Intl.NumberFormat('fr-FR').format(number);console.log(formattedNumber); // 1 234 567,89
```

单复数
---

英文复数是要加 s 的, 比如 apples

```
const numbers = [1, 2, 5, 10, 100];for (const number of numbers) {  const pluralRules = new Intl.PluralRules('en-US'); // 使用英语环境  const pluralForm = pluralRules.select(number);  console.log(`In English, ${number} item${pluralForm !== 'one' ? 's' : ''}.`);}// In English, 1 item.// In English, 2 items.// In English, 5 items.// In English, 10 items.// In English, 100 items.
```

再比如顺序, 第一第二第三, 英文分别为 first, second, third, fourth, fifth. 聪明的你一定发现规律了. 除了 123 后面就是数字 + th. 简写是 1st 2nd. 根据下表可以发现规律

1.  1 → st, 后面除了 11 外. 21-91 都是 21st, 91st 这种
    
2.  2→ nd, 后面除了 12 外. 22-92 都是 22nd, 92nd 这种
    
3.  3 → rd, 后面除了 13 外. 23-93 都是 23rd, 93rd 这种
    
4.  其他都是补 th
    

<table><thead><tr><th><section>数字</section></th><th><section>英文</section></th><th><section>第 N</section></th></tr></thead><tbody><tr><td><section>1</section></td><td><section>One</section></td><td><section>1st</section></td></tr><tr><td><section>2</section></td><td><section>Two</section></td><td><section>2nd</section></td></tr><tr><td><section>3</section></td><td><section>Three</section></td><td><section>3rd</section></td></tr><tr><td><section>4</section></td><td><section>Four</section></td><td><section>4th</section></td></tr><tr><td><section>10</section></td><td><section>Ten</section></td><td><section>10th</section></td></tr><tr><td><section>11</section></td><td><section>Eleven</section></td><td><section>11th</section></td></tr><tr><td><section>12</section></td><td><section>Twelve</section></td><td><section>12th</section></td></tr><tr><td><section>13</section></td><td><section>Thirteen</section></td><td><section>13th</section></td></tr><tr><td><section>20</section></td><td><section>Twenty</section></td><td><section>20th</section></td></tr><tr><td><section>21</section></td><td><section>Twenty-one</section></td><td><section>21st</section></td></tr><tr><td><section>30</section></td><td><section>Thirty</section></td><td><section>22nd</section></td></tr><tr><td><section>31</section></td><td><section>Thirty-one</section></td><td><section>21st</section></td></tr><tr><td><section>100</section></td><td><section>One hundred</section></td><td><section>100th</section></td></tr></tbody></table>

```
const enOrdinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });const suffixes = new Map([  ["one", "st"],  ["two", "nd"],  ["few", "rd"],  ["other", "th"],]);const formatOrdinals = (n) => {  const rule = enOrdinalRules.select(n);  const suffix = suffixes.get(rule);  return `${n}${suffix}`;};formatOrdinals(0); // '0th'formatOrdinals(1); // '1st'formatOrdinals(2); // '2nd'formatOrdinals(3); // '3rd'formatOrdinals(4); // '4th'formatOrdinals(11); // '11th'formatOrdinals(21); // '21st'formatOrdinals(42); // '42nd'formatOrdinals(103); // '103rd'
```

数字格式化
=====

整数分隔和小数分隔
---------

常见的整数分隔符号有千分位分隔, 比如 `1000,000` 也有万位分隔比如 `1000 0000` . 不同语言不一样

常见的小数分隔符号 `.` , 比如 `1000.00` . 不同语言不一样

```
const number = 1234567.89;// 格式化为默认数字格式const formattedNumber = new Intl.NumberFormat().format(number);console.log(formattedNumber); // 输出: 1,234,567.89// 格式化为指定语言环境的数字格式const formattedNumberDE = new Intl.NumberFormat('de-DE').format(number);console.log(formattedNumberDE); // 输出: 1.234.567,89// 格式化为指定语言环境的数字格式const formattedNumberFR = new Intl.NumberFormat('fr-FR').format(number);console.log(formattedNumberFR); // 输出: 1 234 567,89const formattedNumberCN = new Intl.NumberFormat('zh-CN').format(number);console.log(formattedNumberCN)  // 输出: 1,234,567.89
```

也可以通过参数配置控制小数部分最多 / 最少有多少位

```
const number = 1234567.89123;const formattedNumber = new Intl.NumberFormat('en-US', {  style: 'decimal', // 可选 'decimal' 表示常规数字格式  maximumFractionDigits: 3, // 小数部分最多显示三位}).format(number);console.log(formattedNumber); // 输出: 1,234,567.891
```

百分比
---

正常百分比是 0-100 数字 +%, 但是法语环境百分比符号习惯是 '%'而不是'%', 多了一个空格

```
const percentage = 0.75;// 使用默认语言环境const formattedPercentageDefault = new Intl.NumberFormat('fr-FR', {  style: 'percent'}).format(percentage);console.log(formattedPercentageDefault); // 输出: '75 %'// 使用指定语言环境const formattedPercentageFR = new Intl.NumberFormat('fr-FR', {  style: 'percent',  minimumFractionDigits: 2,  maximumFractionDigits: 2,}).format(percentage);console.log(formattedPercentageFR); // 输出: '75,00 %'// 使用默认语言环境const formattedPercentageUS = new Intl.NumberFormat('en-US', {  style: 'percent'}).format(percentage);console.log(formattedPercentageUS); // 输出: '75%'// 使用指定语言环境const formattedPercentageCN = new Intl.NumberFormat('zh-CN', {  style: 'percent',  minimumFractionDigits: 2,  maximumFractionDigits: 2,}).format(percentage);console.log(formattedPercentageCN); // 输出: '75.00%'
```

### 缩写

```
console.log(new Intl.NumberFormat('en-US', { notation: "compact" , compactDisplay: "short", maximumFractionDigits: 2 }).format(987654321)) // 987.65Mconsole.log(new Intl.NumberFormat('zh-CN', { notation: "compact" , compactDisplay: "short", maximumFractionDigits: 2 }).format(987654321)) // 9.88亿
```

货币
==

货币符号
----

比如人民币是 `¥` , 美元是 `$` , 欧元 `€` , 英镑 `£`

```
new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).formatToParts().filter(i => i.type === 'currency')[0].value // '$'new Intl.NumberFormat('zh-CN', { style: 'currency', currency: 'CNY' }).formatToParts().filter(i => i.type === 'currency')[0].value // '¥'new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).formatToParts().filter(i => i.type === 'currency')[0].value // '€'
```

货币格式化
-----

用常见的几个经济体和身边用的多的 case 举例说明, 注意看输出

```
// 美元 $是美元符号const numberUSD = 123456789.12;const formattedNumberUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(numberUSD);console.log(formattedNumberUSD); // $123,456,789.12// 人民币 ¥是人民币符号const numberCNY = 123456789.12;const formattedNumberCNY = new Intl.NumberFormat('zh-CN', { style: 'currency', currency: 'CNY' }).format(numberCNY);console.log(formattedNumberCNY); // ¥123,456,789.12// 欧元 €是欧元符号const numberEUR = 123456789.12;const formattedNumberEUR = new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(numberEUR);console.log(formattedNumberEUR); // 123.456.789,12 €// 日元const numberJPY = 123456789.12;const formattedNumberJPY = new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(numberJPY);console.log(formattedNumberJPY); // ¥123,456,789// 英镑 £是英镑符号const numberGBP = 123456789.12;const formattedNumberGBP = new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }).format(numberGBP);console.log(formattedNumberGBP); // £123,456,789.12// 港币const numberHKD = 123456789.12;const formattedNumberHKD = new Intl.NumberFormat('zh-HK', { style: 'currency', currency: 'HKD' }).format(numberHKD);console.log(formattedNumberHKD); // HK$123,456,789.12// 韩元const numberKRW = 123456789.12;const formattedNumberKRW = new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW' }).format(numberKRW);console.log(formattedNumberKRW); // ₩123,456,789.12
```

货币的兼容性兜底可以用 `Number.prototype.toLocaleString` 实现, 也可以用 formatjs 提供的 polyfill

```
// 美元 $是美元符号const numberUSD = 123456789.12;const formattedNumberUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(numberUSD);const formatttdNumberUSDByLocaleString = Number(numberUSD).toLocaleString('en-US', { style: 'currency', currency: 'USD' });console.log(formattedNumberUSD); // $123,456,789.12console.log(numberUSD.toLocaleString()) // 123,456,789.12console.log(formatttdNumberUSDByLocaleString) // $123,456,789.12
```

货币单位显示
------

比如美国是美元, 中国有人民币. 可以直接格式化出来

```
currencyNames = new Intl.DisplayNames(["zh-Hans"], { type: "currency" });console.log(currencyNames.of("USD")); // "美元"console.log(currencyNames.of("EUR")); // "欧元"console.log(currencyNames.of("TWD")); // "新台币"console.log(currencyNames.of("CNY")); // "人民币"currencyNames = new Intl.DisplayNames(["zh-Hant"], { type: "currency" });console.log(currencyNames.of("USD")); // "美元"console.log(currencyNames.of("EUR")); // "歐元"console.log(currencyNames.of("TWD")); // "新台幣"console.log(currencyNames.of("CNY")); // "人民幣"
```

排序 & 列表
=======

Intl. Collator
--------------

常见的电话本, 地址簿排序. 不同语言因为字母转换后排序不一致. **「`Intl.Collator`」** 是 JavaScript 的国际化 API 之一，用于字符串比较和排序，以便在多语言环境中执行正确的排序操作。它允许你创建一个 **「`Collator`」** 对象，用于根据特定语言和区域设置执行字符串比较和排序，考虑到不同语言的差异。

```
console.log(['Z', 'a', 'z', 'ä'].sort(new Intl.Collator('de').compare));// Expected output: Array ["a", "ä", "z", "Z"]console.log(['Z', 'a', 'z', 'ä'].sort(new Intl.Collator('sv').compare));// Expected output: Array ["a", "z", "Z", "ä"]console.log(['Z', 'a', 'z', 'ä'].sort(new Intl.Collator('de', { caseFirst: 'upper' }).compare));// Expected output: Array ["a", "ä", "Z", "z"]//创建一个Intl.Collator对象const collator = new Intl.Collator('en-US', { sensitivity: 'base', usage: 'sort' });// 可以看出以下输出是按照拼音排序, guang jin mei ming tian yangconsole.log(['今','天','阳','光', '明', '媚'].sort(new Intl.Collator('zh').compare)); // ['光', '今', '媚', '明', '天', '阳']
```

可以发现 options 可以传递参数 usage 和 sensitivity, 有如下取值

1.  **「排序方式 (usage)」**: **「`usage`」** 选项指定排序的目的
    

*   `'sort'`：用于排序。
    
*   `'search'`：用于搜索操作，通常不区分大小写。
    

3.  **「敏感性 (sensitivity)」**: **「`sensitivity`」** 选项指定字符串比较的敏感性级别
    

*   `'base'`：基本敏感性，不区分重音符号。
    
*   `'accent'`：考虑重音符号，但不区分大小写。
    
*   `'case'`：区分大小写，同时考虑重音符号。
    
*   `'case'`：区分大小写，但不考虑重音符号。
    

5.  大小写 (caseFirst)
    

*   `"upper"`：表示大写字母（uppercase）在排序中优先考虑。这意味着排序会先考虑所有大写字母，然后再考虑小写字母。在 **「`caseFirst: "upper"`」** 情况下，大写字母会排在小写字母之前。
    
*   `"lower"`：表示小写字母（lowercase）在排序中优先考虑。这意味着排序会先考虑所有小写字母，然后再考虑大写字母。在 **「`caseFirst: "lower"`」** 情况下，小写字母会排在大写字母之前。
    
*   `"false"`：表示不指定大写字母和小写字母的排序顺序，它们会一起排序，不区分大小写。
    

7.  ignorePunctuation: boolean, 表示是否忽略标点符号
    

有如下的应用方式

### 字符串比较

```
const collator = new Intl.Collator('en-US', { sensitivity: 'base', usage: 'sort' }); //创建一个Intl.Collator对象const result = collator.compare('apple', 'Banana');console.log(result); // 根据配置输出 -1（apple 在 Banana 前面）
```

### 数组排序

我们知道英文字母默认按照 ASCII 排序, 而如果需要 AaBb 这样排序只能自己写排序回调

```
// 创建一个自定义Collator对象const customCollator = new Intl.Collator('en-US', {  sensitivity: 'base',  usage: 'sort',  ignorePunctuation: true,  caseFirst: 'false',});// 自定义比较函数, 忽略空格并不区分大小写function customCompare(a, b) {  // 移除字符串中的空格并转为小写后再比较  const stringA = a.replace(/\\s/g, '').toLowerCase();  const stringB = b.replace(/\\s/g, '').toLowerCase();  if (stringA < stringB) {    return -1;  }  if (stringA > stringB) {    return 1;  }  return 0;}const data = ['Apple', 'banana', 'cherry', 'apple pie', 'Banana Split', 'cherry tart'];const data2 = data.slice()// 老方式: 使用sort回调排序console.log(data.sort(customCompare)); // 输出排序结果：['Apple', 'apple pie', 'banana', 'Banana Split', 'cherry', 'cherry tart']// 新方式: 使用自定义Collator对象进行排序console.log(data2.sort(customCollator.compare)); // 输出排序结果：['Apple', 'apple pie', 'banana', 'Banana Split', 'cherry', 'cherry tart']
```

可以发现两种方式结果一样, 但是明显 Intl. Collator 更加优雅, 是配置化的.

Intl.**「ListFormat」**
---------------------

**「`Intl.ListFormat`」** 是 JavaScript 的国际化 API 之一，它用于格式化列表，以便在多语言环境中创建自然语言的列表表示。`Intl.ListFormat` 允许你指定列表项的连接方式（如逗号、"和" 等），以及列表项的样式和语言设置。

```
const listFormatter = new Intl.ListFormat('en-US', { style: 'long', type: 'disjunction' });const items = ['apples', 'bananas', 'cherries'];const formattedList = listFormatter.format(items);console.log(formattedList); // 根据配置输出例如："apples, bananas, or cherries"const listFormatter = new Intl.ListFormat('en-US', { style: 'short', type: 'conjunction' });const items = ['apples', 'bananas', 'cherries'];const formattedList = listFormatter.format(items);console.log(formattedList); // 根据配置输出例如："apples, bananas, & cherries"const listFormatter = new Intl.ListFormat('en-US', { style: 'narrow', type: 'conjunction' });const items = ['apples', 'bananas', 'cherries'];const formattedList = listFormatter.format(items);console.log(formattedList); // 根据配置输出例如："apples, bananas, cherries"
```

可以发现 options 可以传递参数 style 和 type, 有如下取值

1.  **「样式 (style)」**: **「`style`」** 选项指定列表的样式，有三个可能的值
    

*   `'long'`：使用完整的语言表达，例如 "A, B, and C"。
    
*   `'short'`：使用缩略形式，例如 "A, B, & C"。
    
*   `'narrow'`：使用极简的形式，例如 "A B C"。
    

3.  **「连接方式 (type)」**: **「`type`」** 选项指定连接列表项的方式，有两个可能的值
    

*   `'conjunction'`：使用 "和"（默认值），例如 "A、B 和 C"。
    
*   `'disjunction'`：使用 "或"，例如 "A、B 或 C"。
    

日历
==

日历是一种常见的东西, 在中国我们经常接触到公历和农历，公历全称格里高利历, 英文 gregory。

现在国家节日很多都是跟随农历的，比如春节，中秋节等。以前家家人手一本农历, 上面会今日宜做什么, 现在很少见但是老人家还是信这个。

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGmaGXOCcOaJZ7iaQc1TSfZjc79aNc7M6WsYxINribUl0goVEUJ8P7Ljxg/640?wx_fmt=png&from=appmsg)

而与此相同, 每个地方都有自己的历法

1.  **「伊斯兰历（Hijri Calendar）」**：也称为伊斯兰农历，是伊斯兰教的官方日历，基于月亮的循环。伊斯兰历的年份比公历年份短，每年有 12 个月，因此季节日期会变化。
    
2.  **「希伯来历（Hebrew Calendar）」**：希伯来历是犹太教的官方日历，基于太阳和月亮的周期。它有 13 个月，其中一些月份可以有不同的天数，以保持与农历季节的一致性。
    
3.  **「农历（Lunar Calendar）」**：农历基于月亮的循环，不同地区和文化有不同的农历系统，如中国农历、韩国农历、越南农历等。
    
4.  **「波斯历（Persian Calendar）」**：波斯历，也称波斯太阳历，是伊朗和一些邻近国家使用的太阳历，与公历有一些差异。
    
5.  **「印度历法（Indian Calendar）」**：印度有多种历法，包括维基历（Vikram Samvat）、国民历法（Saka Samvat）、泰米尔历法（Tamil Calendar）等。
    
6.  **「巴哈伊历（Bahá'í Calendar）」**：巴哈伊信仰使用的独特日历，包括 19 个月，每个月 19 天。
    
7.  **「民族历法」**：一些文化和民族拥有自己的独特历法，用于纪念特定历史事件和节日。
    

```
const date = new Date(); // 当前日期, Mon Oct 30 2023 20:00:50 GMT+0800 (中国标准时间)const formattedDate = new Intl.DateTimeFormat('ar-SA-u-ca-islamic', { year: 'numeric', month: 'long', day: 'numeric' }).format(date);console.log(formattedDate); // ١٦ ربيع الآخر ١٤٤٥ هـconst date = new Date(1994, 1, 26);const formattedDate = new Intl.DateTimeFormat('zh-CN-u-ca-chinese', { year: 'numeric', month: 'long', day: 'numeric' }).format(date);console.log(formattedDate); // 1994甲戌年正月17// 不同语言下不同日历的名称const calendarNames = new Intl.DisplayNames('en-US', { type: 'calendar' });console.log(calendarNames.of('gregory')); // 输出：Gregorianconsole.log(calendarNames.of('islamic')); // 输出：Islamicconst calendarNames = new Intl.DisplayNames('zh-CN', { type: 'calendar' });console.log(calendarNames.of('gregory')); // 输出：公历console.log(calendarNames.of('islamic')); // 输出：伊斯兰历
```

除了上述 gregory 格里高利历, 取值还有下面这些

1.  **"buddhist"**：佛教历（Buddhist Calendar）
    
2.  **"chinese"**：中国农历（Chinese Lunar Calendar）
    
3.  **"coptic"**：科普特历（Coptic Calendar）
    
4.  **"ethiopic"**：埃塞俄比亚历（Ethiopic Calendar）
    
5.  **"gregory"**：格里高利历（Gregorian Calendar，即公历）
    
6.  **"hebrew"**：希伯来历（Hebrew Calendar）
    
7.  **"indian"**：印度历法（Indian Calendar），包括维基历（Vikram Samvat）等
    
8.  **"islamic"**：伊斯兰历（Islamic Calendar）
    
9.  **"persian"**：波斯历（Persian Calendar）
    
10.  **"islamic-civil"**：伊斯兰历的公民版本（Islamic Civil Calendar），通常用于文书、合同等民事事务
    

星期
--

不得不说日本的和历, 真的是很神奇. 不是中文的周一到周日, 也不是 Sunday-Saturday. 首先日本还有皇帝, 有皇帝就有年号. 常见下面的一些年份

1.  **「明治时代 (Meiji Era)」**:
    

*   年号：明治（Meiji）
    
*   年份范围：1868 年 - 1912 年
    
*   注释：明治时代标志着日本的近代化和工业化的开始。
    

3.  **「大正时代 (Taisho Era)」**:
    

*   年号：大正（Taisho）
    
*   年份范围：1912 年 - 1926 年
    
*   注释：大正时代是日本的一个相对短暂时期，也标志着日本的一些政治和社会变革。
    

5.  **「昭和时代 (Showa Era)」**:
    

*   年号：昭和（Showa）
    
*   年份范围：1926 年 - 1989 年
    
*   注释：昭和时代见证了日本的战争和战后重建，以及日本成为现代工业强国。
    

7.  **「平成时代 (Heisei Era)」**:
    

*   年号：平成（Heisei）
    
*   年份范围：1989 年 - 2019 年
    
*   注释：平成时代包括了日本的经济繁荣和一些社会变革。
    

9.  **「令和时代 (Reiwa Era)」**: 令和系奥特曼 (https://baike.baidu.com/item/%E4%BB%A4%E5%92%8C%E7%B3%BB%E5%A5%A5%E7%89%B9%E6%9B%BC/50340521)
    

*   年号：令和（Reiwa）
    
*   年份范围：2019 年 - 至今
    
*   注释：令和时代是日本当前的年号，始于 2019 年 5 月 1 日，标志着新的时代的开始。
    

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGiaKnzHsEYsxEYZHrmIXZBdJxKxqvDrUzFer7MGPlOzHyOmzTl8bIq0g/640?wx_fmt=png&from=appmsg)

可以看到日本的日历起始时周日 (日), 但是周一到周六分别对应月火水木金土. 与众不同

```
// 获取今天过去7天的日期// 日期对象const today = new Date();// 创建一个选项对象，指定输出的语言和风格const optionsCN = { weekday: 'long' };const optionsJP = { weekday: 'long' };// 获取过去一周的日期console.log('\n过去一周的日期：');const CNArr = []const JPArr = []for (let i = 0; i < 7; i++) {  const pastDate = new Date(today);  pastDate.setDate(today.getDate() - i);  CNArr.unshift(new Intl.DateTimeFormat('zh-CN', optionsCN).format(pastDate)) JPArr.unshift(new Intl.DateTimeFormat('ja-JP', optionsJP).format(pastDate))}console.log('CNArr', CNArr.join(' ')) // CNArr 星期二 星期三 星期四 星期五 星期六 星期日 星期一console.log('JPArr', JPArr.join(' ')) // JPArr 火曜日 水曜日 木曜日 金曜日 土曜日 日曜日 月曜日
```

日历单位
----

```
const dateTimeFields = new Intl.DisplayNames('en-US', { type: 'dateTimeField' });console.log(dateTimeFields.of('era')); // 输出：Era, 纪元的意思console.log(dateTimeFields.of('year')); // 输出：Yearconsole.log(dateTimeFields.of('month')); // 输出：Monthconsole.log(dateTimeFields.of('day')); // 输出：Dayconsole.log(dateTimeFields.of('weekday')); // 输出：Day of the weekconsole.log(dateTimeFields.of('hour')); // 输出：Hourconsole.log(dateTimeFields.of('minute')); // 输出：Minuteconsole.log(dateTimeFields.of('second')); // 输出：Secondconsole.log(dateTimeFields.of('quarter')); // 输出：Quarterconst dateTimeFields = new Intl.DisplayNames('ja-JP', { type: 'dateTimeField' });console.log(dateTimeFields.of('era')); // 输出：時代console.log(dateTimeFields.of('year')); // 输出：年console.log(dateTimeFields.of('month')); // 输出：月console.log(dateTimeFields.of('day')); // 输出：日console.log(dateTimeFields.of('weekday')); // 输出：曜日console.log(dateTimeFields.of('hour')); // 输出：時console.log(dateTimeFields.of('minute')); // 输出：分console.log(dateTimeFields.of('second')); // 输出：秒console.log(dateTimeFields.of('quarter')); // 输出：四半期
```

每周第一天
-----

en-US 一般每周第一天是周日, 而 zh-CN 一般每周第一天是周一. 可以通过如下信息判断

Intl. Locale 函数返回属性里 firstDay 是一个数字，其中 0 或 7 表示星期日，1 表示星期一，依此类推。不同的地区和文化可能会将每周的第一天设置为不同的日期，因此这个属性可以帮助你确定每周的起始日期，例如，星期天或星期一。

```
(new Intl.Locale('zh-CN')).weekInfo // {"firstDay":1,"weekend":[6,7],"minimalDays":1}(new Intl.Locale('en-US')).weekInfo // {"firstDay":7,"weekend":[6,7],"minimalDays":1}const locale = 'zh-CN'console.log(new Intl.DateTimeFormat(locale, { weekday: "long" }).format(new Date(0, 0, new Intl.Locale(locale).weekInfo.firstDay))) // '星期一'const locale = 'en-US'console.log(new Intl.DateTimeFormat(locale, { weekday: "long" }).format(new Date(0, 0, new Intl.Locale(locale).weekInfo.firstDay))) // 'Sunday'
```

能生效的原因就是 `new Date(0,0,7)` 等价于 `new Date(1900,0,7)` 对应 1900.1.7(UTC+0), 此时对应 us 的 sunday. 而 `new Date(0,0,1)` 对应 1900.1.1(UTC+0), 对应 cn 的星期一

如何写一个国际化日历组件
------------

1.  zh-CN 下是星期一开头
    
2.  en-US 是 Sunday 开头
    
3.  日语环境符合 火曜日 水曜日 木曜日 金曜日 土曜日 日曜日 月曜日等描述
    

Intl-region-language-calendar：https://codesandbox.io/p/devbox/intl-region-language-calendar-xm7ls8?embed=1&file=%2Fsrc%2FApp.tsx

#### 实现细节

1.  如何获取一周的第一天
    

```
const localeUS = 'en-US'new Intl.DateTimeFormat(localeUS, { weekday: "long" }).format(new Date(0, 0, new Intl.Locale(localeUS).weekInfo.firstDay)) // 'Sunday'const localeCN = 'zh-CN'new Intl.DateTimeFormat(localeCN, { weekday: "long" }).format(new Date(0, 0, new Intl.Locale(localeCN).weekInfo.firstDay)) // '星期一'
```

1.  输出一周 7 天
    

```
const locale = "en-US";const firstDay = new Intl.Locale(locale).weekInfo.firstDay;const formatInstace = new Intl.DateTimeFormat(locale, { weekday: "long" });for (let i = 0; i < 7; i++) {  console.log(formatInstace.format(new Date(0, 0, firstDay + i)));}// Sunday// Monday// Tuesday// Wednesday// Thursday// Friday// Saturdayconst localeCN = "zh-CN";const firstDayCN = new Intl.Locale(localeCN).weekInfo.firstDay;const formatInstaceCN = new Intl.DateTimeFormat(localeCN, { weekday: "long" });for (let i = 0; i < 7; i++) {  console.log(formatInstaceCN.format(new Date(0, 0, firstDayCN + i)));}// 星期一// 星期二// 星期三// 星期四// 星期五// 星期六// 星期日
```

Intl 支持
=======

支持查询
----

可以通过 API, `Intl.supportedValuesOf` 获取到所有支持的

```
const calendars = Intl.supportedValuesOf("calendar");console.log(calendars); // 输出所有支持的日历系统// (18) ['buddhist', 'chinese', 'coptic', 'dangi', 'ethioaa', 'ethiopic', 'gregory', 'hebrew', 'indian', 'islamic', 'islamic-civil', 'islamic-rgsa', 'islamic-tbla', 'islamic-umalqura', 'iso8601', 'japanese', 'persian', 'roc']const currencies = Intl.supportedValuesOf("currency");console.log(currencies); // 输出所有支持的货币代码// (159) ['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BRL', 'BSD', 'BTN', 'BWP', 'BYN', 'BZD', 'CAD', 'CDF', 'CHF', 'CLP', 'CNY', 'COP', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', …]const timeZones = Intl.supportedValuesOf("timeZone");console.log(timeZones); // 输出所有支持的时区// (428) ['Africa/Abidjan', 'Africa/Accra', 'Africa/Addis_Ababa', 'Africa/Algiers', 'Africa/Asmera', 'Africa/Bamako', 'Africa/Bangui', 'Africa/Banjul', 'Africa/Bissau', 'Africa/Blantyre', 'Africa/Brazzaville', 'Africa/Bujumbura', 'Africa/Cairo', 'Africa/Casablanca', 'Africa/Ceuta', 'Africa/Conakry', 'Africa/Dakar', 'Africa/Dar_es_Salaam', 'Africa/Djibouti', 'Africa/Douala', 'Africa/El_Aaiun', 'Africa/Freetown', 'Africa/Gaborone', 'Africa/Harare', 'Africa/Johannesburg', 'Africa/Juba', 'Africa/Kampala', 'Africa/Khartoum', 'Africa/Kigali', 'Africa/Kinshasa', 'Africa/Lagos', 'Africa/Libreville', 'Africa/Lome', 'Africa/Luanda', 'Africa/Lubumbashi', 'Africa/Lusaka', 'Africa/Malabo', 'Africa/Maputo', 'Africa/Maseru', 'Africa/Mbabane', 'Africa/Mogadishu', 'Africa/Monrovia', 'Africa/Nairobi', 'Africa/Ndjamena', 'Africa/Niamey', 'Africa/Nouakchott', 'Africa/Ouagadougou', 'Africa/Porto-Novo', 'Africa/Sao_Tome', 'Africa/Tripoli', 'Africa/Tunis', 'Africa/Windhoek', 'America/Adak', 'America/Anchorage', 'America/Anguilla', 'America/Antigua', 'America/Araguaina', 'America/Argentina/La_Rioja', 'America/Argentina/Rio_Gallegos', 'America/Argentina/Salta', 'America/Argentina/San_Juan', 'America/Argentina/San_Luis', 'America/Argentina/Tucuman', 'America/Argentina/Ushuaia', 'America/Aruba', 'America/Asuncion', 'America/Bahia', 'America/Bahia_Banderas', 'America/Barbados', 'America/Belem', 'America/Belize', 'America/Blanc-Sablon', 'America/Boa_Vista', 'America/Bogota', 'America/Boise', 'America/Buenos_Aires', 'America/Cambridge_Bay', 'America/Campo_Grande', 'America/Cancun', 'America/Caracas', 'America/Catamarca', 'America/Cayenne', 'America/Cayman', 'America/Chicago', 'America/Chihuahua', 'America/Ciudad_Juarez', 'America/Coral_Harbour', 'America/Cordoba', 'America/Costa_Rica', 'America/Creston', 'America/Cuiaba', 'America/Curacao', 'America/Danmarkshavn', 'America/Dawson', 'America/Dawson_Creek', 'America/Denver', 'America/Detroit', 'America/Dominica', 'America/Edmonton', 'America/Eirunepe', …]
```

低版本兼容
-----

Intl 是浏览器对 i18n 提供的底层 API, 用于处理国际化相关内容. 附带 browerstack 云真机测试工具 (caniuse 推荐): https://live.browserstack.com/dashboard 如果没处理好兼容性问题直接使用 API, 会报 JS Error. 内容为`Intl.DisplayNames is not a constructor`

对应的, 一些操作系统低版本的用户 (长期不升级系统) 会遇到 JS Error 导致白屏

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGCr23jvR08lmUkqDd4ibdPt0u5NfDjdov994YxgVawfBcrzch6eycAEg/640?wx_fmt=png&from=appmsg)Google pixel4(2019, October 15 发行)

### formatjs

可以用 formatjs 提供的 polyfill 做低版本兼容: https://formatjs.io/docs/getting-started/installation

1.  支持关系有先后依赖, 需要按照依赖顺序依次倒入对应的包![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGImngVA9L1pB4MtCAzxdeiac5b1uRnFWvxNXyjKZwPr2dlXo5iaicm1sQA/640?wx_fmt=png&from=appmsg)
    
2.  移动端场景如小程序, 如果全量导入移动端场景会让包体积爆炸 (普通压缩包 Gzip 后 2.6M, 全量导入后会到 9.1M). 最后 polyfill 按照顺序依次导入, 且移动端场景只兜底英文部分, 限制包体积在 3M 内
    

```
async function loadPolyfill() {    // 如果当前环境不支持 Intl 或者 Intl.DisplayNames    if (!window.Intl || !window.Intl.DisplayNames) {        window.Intl = window.Intl || {}        // 加载 polyfill        await import('@formatjs/intl-getcanonicallocales/polyfill-force')        await import('@formatjs/intl-locale/polyfill-force')        await import('@formatjs/intl-displaynames/polyfill-force')        await import('@formatjs/intl-displaynames/locale-data/en')        return false    } else {        // 当前环境支持 Intl.DisplayNames API，不需要 Polyfill        return true    }}
```

### Why not Babel?

众所周知 Babel 有一个 babel-preset-env(https://www.babeljs.cn/docs/babel-preset-env#how-does-it-work), 用于在编译代码时智能 (基于 core-js-compat(https://www.npmjs.com/package/core-js-compat)) 引入 helper 和 polyfill 智能的含义: 可以设置最低兼容的浏览器 (https://github.com/browserslist/browserslist#queries) 和代码, 动态引用所需的 helper 和 polyfill

```
// babel.config.jsmodule.exports = {  presets: [    [      '@babel/preset-env',      {        useBuiltIns: 'usage', // 根据每个文件里面，用到了哪些es的新特性和targets导入polyfill，更加精简        corejs: 3, // 指定 core-js 版本        targets: "> 0.25%, not dead" // 指定目标浏览器, 选取全球使用率超过 0.25% 的浏览器版本      },    ],  ],};
```

**「babel 底层使用 core-js(https://github.com/zloirock/core-js) 进行 polyfill, 但是 core-js 不包含 Intl API 部分的 polyfill(https://github.com/zloirock/core-js?tab=readme-ov-file#missing-polyfills), 所以 babel 并不能为 Intl API 做 polyfill」**

![](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zibGur3rh5gH17DRH0M0l7ibGf4ibT7uUvzAR27fKTf66cvFicED9IfyKrCX1XauOEibaSJicuoIqj77lQQ/640?wx_fmt=png&from=appmsg)

Nodejs 使用
---------

1.  安装
    

```
npm i @formatjs/intl
```

1.  使用
    

```
import {createIntl, createIntlCache} from '@formatjs/intl'// This is optional but highly recommended// since it prevents memory leakconst cache = createIntlCache()const intlFr = createIntl(  {    locale: 'fr-FR',    messages: {},  },  cache)const intlEn = createIntl(  {    locale: 'en-US',    message: {},    cache  })// Call imperativelyconsole.log(intlFr.formatNumber(2000000000000)) // 2 000 000 000 000console.log(intlEn.formatNumber(2000000000000)) // 2,000,000,000,000
```