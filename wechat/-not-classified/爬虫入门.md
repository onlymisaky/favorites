> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/-syB8r3Fq9wzrZS9-l1JZA)

> 本文作者系 360 奇舞团前端开发工程师

很多前端小伙伴在日常业务中很少涉及到爬虫相关的内容，觉得爬虫是后端工程师的专属技能。但实际上，**爬虫技术是前端开发者应该掌握的基本技能之一**。

### 爬虫与前端的关系

*   **数据获取**：前端经常需要从各种 API 获取数据，爬虫技术能帮你理解数据是如何被获取的
    
*   **测试验证**：爬虫可以帮你验证前端页面的数据展示是否正确
    
*   **竞品分析**：了解竞争对手的产品功能和数据展示方式
    
*   **个人项目**：想要开发一些有趣的小工具，爬虫技术必不可少
    
*   **技术视野**：掌握爬虫技术能让你对 Web 技术有更全面的理解
    

### 学习爬虫的好处

无论是想要开发数据可视化项目、构建个人博客系统，还是想要了解 Web 安全机制，爬虫技术都能给你带来意想不到的收获。让我们一起来探索这个既实用又有趣的技术领域吧！

什么是爬虫？
------

**网络爬虫（Web Spider）** 是一种自动获取网页内容的程序，它模拟浏览器行为，向网站发起请求，获取资源后分析并提取有用数据。

### 技术原理

从技术层面来说，爬虫通过程序模拟浏览器请求站点的行为，把站点返回的 HTML 代码、JSON 数据、二进制数据（图片、视频）爬取到本地，进而提取需要的数据并存储使用。

两种获取网络数据的方式
-----------

**方式 1：传统浏览器方式**

```
浏览器提交请求 → 下载网页代码 → 解析成页面
```

**方式 2：爬虫方式**

```
模拟浏览器发送请求 → 获取网页代码 → 提取有用数据 → 存储到数据库或文件
```

爬虫要做的就是方式 2。

### 详细流程分解

#### 发起请求

*   使用 HTTP 库向目标站点发起请求
    
*   请求包含：请求头、请求体等
    

#### 获取响应内容

*   服务器正常响应时得到 Response
    
*   Response 包含：HTML、JSON、图片、视频等
    

#### 解析内容

*   **HTML 数据**：正则表达式、XPath、Beautiful Soup、CSS 选择器
    
*   **JSON 数据**：JSON 模块
    
*   **二进制数据**：以 wb 方式写入文件
    

#### 保存数据

*   数据库：MySQL、MongoDB、Redis
    
*   文件：CSV、JSON、Excel 等
    

### 流程图

![](https://mmbiz.qpic.cn/sz_mmbiz_png/cAd6ObKOzEDK4apw3gLJw6ssI0gZ03JgU3xqA3VOP1CRcEQHvWSpZvibicOp0gg7wY5hP9Qp6uxibqCPPKdyzu9Dw/640?wx_fmt=png&from=appmsg#imgIndex=0)爬虫流程图

编程语言环境对比
--------

爬虫开发并不局限于单一编程语言，不同语言各有优势。虽然 Python 生态更丰富，但其他语言同样可以构建强大的爬虫系统。

<table><thead><tr><th><section>特性</section></th><th><section>Python</section></th><th><section>Node.js</section></th><th><section>Java</section></th><th><section>Go</section></th><th><section>C#</section></th></tr></thead><tbody><tr><td><strong>生态丰富度</strong></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐</section></td><td><section>⭐⭐⭐</section></td></tr><tr><td><strong>学习曲线</strong></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐</section></td></tr><tr><td><strong>性能表现</strong></td><td><section>⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td></tr><tr><td><strong>部署便利性</strong></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td></tr><tr><td><strong>社区支持</strong></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐⭐</section></td><td><section>⭐⭐⭐</section></td></tr></tbody></table>

#### Python - 全能型爬虫开发

*   **适用场景**：数据挖掘、学术研究、快速原型开发
    
*   **优势**：丰富的爬虫库（Scrapy、BeautifulSoup、Selenium）、数据处理能力强（Pandas、NumPy）
    
*   **典型应用**：新闻聚合、电商数据采集、社交媒体分析
    
*   **推荐人群**：数据科学家、研究人员、爬虫初学者
    

#### Node.js - 高并发网络爬虫

*   **适用场景**：大规模并发爬取、实时数据抓取、API 密集型爬虫
    
*   **优势**：异步非阻塞 I/O、事件驱动架构、丰富的 HTTP 客户端库
    
*   **典型应用**：实时价格监控、社交媒体流数据、高频数据采集
    
*   **推荐人群**：前端开发者、全栈工程师、需要高并发的场景
    

#### Java - 企业级爬虫系统

*   **适用场景**：大型分布式爬虫、企业级应用、需要高稳定性的场景
    
*   **优势**：强大的多线程支持、成熟的 JVM 生态、丰富的企业级框架
    
*   **典型应用**：搜索引擎爬虫、大规模数据采集、企业数据整合
    
*   **推荐人群**：企业开发者、系统架构师、需要高可靠性的场景
    

#### Go - 高性能爬虫引擎

*   **适用场景**：高性能爬虫、系统级爬虫、资源受限环境
    
*   **优势**：原生并发支持、内存占用低、编译型语言性能优异
    
*   **典型应用**：网络监控工具、系统级爬虫、微服务架构中的爬虫组件
    
*   **推荐人群**：系统开发者、DevOps 工程师、性能敏感场景
    

#### C# - Windows 生态爬虫

*   **适用场景**：Windows 平台爬虫、.NET 生态集成、桌面应用爬虫
    
*   **优势**：强大的 Windows API 支持、优秀的 GUI 开发能力、.NET 生态丰富
    
*   **典型应用**：Windows 应用数据提取、企业内网爬虫、桌面爬虫工具
    
*   **推荐人群**：Windows 开发者、.NET 开发者、企业内网应用场景
    

#### Python 生态优势

```
# Python爬虫生态示例import requestsfrom bs4 import BeautifulSoupimport scrapyfrom selenium import webdriver# 丰富的库支持# - requests: HTTP请求# - BeautifulSoup: HTML解析# - scrapy: 爬虫框架# - selenium: 浏览器自动化# - pandas: 数据处理# - numpy: 数值计算
```

#### Node.js 生态优势

```
// Node.js爬虫生态示例const axios = require('axios');const cheerio = require('cheerio');const puppeteer = require('puppeteer');const playwright = require('playwright');// 强大的异步处理能力// - axios: HTTP请求// - cheerio: HTML解析// - puppeteer: Chrome自动化// - playwright: 多浏览器支持
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/cAd6ObKOzEDK4apw3gLJw6ssI0gZ03JgOMZPrQblEDppsRR8EwI6b1YlVetWiaxe1lIrlKhQfN4KDOibiaricE4atA/640?wx_fmt=png&from=appmsg#imgIndex=1)puppeteer 和 playwright 的历史渊源

浏览器自动化工具对比
----------

<table><thead><tr><th><section>工具名称</section></th><th><section>支持语言</section></th><th><section>特点</section></th><th><section>适用场景</section></th></tr></thead><tbody><tr><td><strong>Puppeteer</strong></td><td><section>Node.js</section></td><td><section>Chrome 官方支持、功能完整</section></td><td><section>动态内容、SPA 应用</section></td></tr><tr><td><strong>Playwright</strong></td><td><section>Node.js/Python/Java/C#</section></td><td><section>多浏览器支持、现代化 API</section></td><td><section>跨浏览器测试、企业级</section></td></tr><tr><td><strong>Selenium</strong></td><td><section>Python/Java/C#/JavaScript</section></td><td><section>成熟稳定、社区支持好</section></td><td><section>传统自动化、兼容性要求高</section></td></tr><tr><td><strong>Cypress</strong></td><td><section>JavaScript</section></td><td><section>前端友好、调试体验佳</section></td><td><section>前端测试、简单爬虫</section></td></tr></tbody></table>

Puppeteer 实战示例
--------------

**Puppeteer** 是 Chrome 官方团队开发的 Node.js 库，提供完整的 Chrome DevTools Protocol API。

#### 核心特性

*   Chrome 官方支持，功能完整
    
*   隐身模式，避免数据干扰
    
*   反检测机制，提高成功率
    
*   异步处理，性能优异
    

#### 完整代码示例

```
const puppeteer = require('puppeteer');class PuppeteerScraper {    constructor(options = {}) {        this.options = {            headless: true,            args: [                '--no-sandbox',                '--disable-setuid-sandbox',                '--disable-dev-shm-usage',                '--disable-accelerated-2d-canvas',                '--no-first-run',                '--no-zygote',                '--disable-gpu'            ],            ...options        };    }    async init() {        this.browser = await puppeteer.launch(this.options);        // 创建隐身模式上下文，避免数据共享干扰        this.context = awaitthis.browser.createIncognitoBrowserContext();                // 反检测设置        awaitthis.context.addInitScript(() => {            // 隐藏webdriver属性            Object.defineProperty(navigator, 'webdriver', {                get: () =>undefined,            });                        // 修改navigator属性            const newProto = navigator.__proto__;            delete newProto.webdriver;            navigator.__proto__ = newProto;        });                returnthis.browser;    }    async createPage() {        const page = awaitthis.context.newPage();                // 设置视口和用户代理        await page.setViewport({ width: 1920, height: 1080 });        await page.setUserAgent('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36...');                // 设置请求拦截        await page.setRequestInterception(true);        page.on('request', (req) => {            // 阻止加载图片、字体等非必要资源            if (['image', 'font', 'media'].includes(req.resourceType())) {                req.abort();            } else {                req.continue();            }        });                return page;    }    async scrape(url, selectors) {        const page = awaitthis.createPage();                try {            await page.goto(url, { waitUntil: 'networkidle0' });                        // 等待关键元素加载            if (selectors.waitFor) {                await page.waitForSelector(selectors.waitFor, { timeout: 10000 });            }                        // 执行页面交互            awaitthis.interactWithPage(page);                        // 提取数据            const data = await page.evaluate((sel) => {                const result = {};                                if (sel.title) {                    const titleEl = document.querySelector(sel.title);                    result.title = titleEl ? titleEl.textContent.trim() : '';                }                                if (sel.content) {                    const contentEl = document.querySelector(sel.content);                    result.content = contentEl ? contentEl.textContent.trim() : '';                }                                if (sel.links) {                    const linkEls = document.querySelectorAll(sel.links);                    result.links = Array.from(linkEls).map(el => ({                        text: el.textContent.trim(),                        href: el.href                    }));                }                                return result;            }, selectors);                        return data;                    } finally {            await page.close();        }    }    async interactWithPage(page) {        // 滚动页面        await page.evaluate(async () => {            awaitnewPromise((resolve) => {                let totalHeight = 0;                const distance = 100;                const timer = setInterval(() => {                    const scrollHeight = document.body.scrollHeight;                    window.scrollBy(0, distance);                    totalHeight += distance;                                        if (totalHeight >= scrollHeight) {                        clearInterval(timer);                        resolve();                    }                }, 100);            });        });                // 处理弹窗        try {            await page.click('.close-button', { timeout: 3000 });        } catch (e) {            // 弹窗不存在        }    }    async close() {        if (this.context) awaitthis.context.close();        if (this.browser) awaitthis.browser.close();    }}// 使用示例asyncfunction example() {    const scraper = new PuppeteerScraper();    await scraper.init();        try {        const data = await scraper.scrape('https://example.com', {            waitFor: '.content',            title: 'h1',            content: '.content',            links: 'a[href]'        });                console.log('抓取结果:', data);            } finally {        await scraper.close();    }}
```

技术选型建议
------

<table><thead><tr><th><section>项目类型</section></th><th><section>推荐技术栈</section></th><th><section>原因</section></th></tr></thead><tbody><tr><td><strong>快速原型</strong></td><td><section>Python + Selenium</section></td><td><section>学习成本低、生态丰富</section></td></tr><tr><td><strong>生产环境</strong></td><td><section>Node.js + Playwright / Puppeteer</section></td><td><section>性能好、多浏览器支持</section></td></tr><tr><td><strong>企业级应用</strong></td><td><section>Java + Selenium</section></td><td><section>稳定性高、团队支持好</section></td></tr><tr><td><strong>高性能需求</strong></td><td><section>Go + Colly</section></td><td><section>并发能力强、资源占用低</section></td></tr></tbody></table>

法律和道德考虑
-------

<table><thead><tr><th><section>原则</section></th><th><section>说明</section></th></tr></thead><tbody><tr><td><strong>遵守 robots.txt</strong></td><td><section>检查网站的爬虫协议</section></td></tr><tr><td><strong>尊重版权</strong></td><td><section>不抓取受版权保护的内容</section></td></tr><tr><td><strong>遵守服务条款</strong></td><td><section>了解目标网站使用条款</section></td></tr><tr><td><strong>合理使用</strong></td><td><section>不过度频繁地请求</section></td></tr></tbody></table>

反爬虫技术
-----

### 智能请求头管理

```
class SmartHeaders {    constructor() {        this.browsers = {            chrome: {                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36...',                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9...',                'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8'            }        };    }    getRandomHeaders() {        const browser = Object.keys(this.browsers)[            Math.floor(Math.random() * Object.keys(this.browsers).length)        ];        return { ...this.browsers[browser] };    }}
```

### 代理池管理

```
class ProxyPool {    constructor() {        this.proxies = [];        this.currentIndex = 0;        this.failedProxies = newMap();    }    getNextProxy() {        if (this.proxies.length === 0) returnnull;                const proxy = this.proxies[this.currentIndex];        this.currentIndex = (this.currentIndex + 1) % this.proxies.length;                return proxy;    }}
```

性能优化技巧
------

### 并发控制

```
const { Cluster } = require('puppeteer-cluster');(async () => {    // 创建一个具有2个并发工作器的集群    const cluster = await Cluster.launch({        concurrency: Cluster.CONCURRENCY_CONTEXT,        maxConcurrency: 2,    });    // 定义任务    await cluster.task(async ({ page, data: url }) => {        await page.goto(url);        const screen = await page.screenshot();        // 存储截图或进行其他操作    });    // 队列任务    cluster.queue('http://www.google.com/');    cluster.queue('http://www.wikipedia.org/');        // 等待所有任务完成    await cluster.idle();        // 关闭集群    await cluster.close();})();
```

### 内存管理

```
class MemoryManager {    constructor() {        this.dataCache = newMap();        this.maxCacheSize = 1000;    }    setCache(key, value, ttl = 300000) {        if (this.dataCache.size >= this.maxCacheSize) {            this.cleanupCache();        }        this.dataCache.set(key, {            value,            timestamp: Date.now(),            ttl        });    }}
```

写在最后
----

第一次写爬虫时，我也觉得这技术很神秘。但当你成功抓取到第一个数据时，那种 "原来如此" 的感觉真的很棒。

### 开始你的爬虫之旅

*   从简单的静态页面开始
    
*   选择一个你熟悉的网站
    
*   动手写代码，不要只看不练
    

_开始你的爬虫探索吧_

-END -

**如果您关注前端 + AI 相关领域可以扫码进群交流**

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/cAd6ObKOzEArGqlLlZmLVB61keywZ2APgWHNwTdK8OicE1utUcAJj1m5ZMFTL8iac51bGglnIeCR5KHicCBh5lh3A/640?wx_fmt=jpeg#imgIndex=2)

添加小编微信进群😊  

关于奇舞团
-----

奇舞团是 360 集团最大的大前端团队，非常重视人才培养，有工程师、讲师、翻译官、业务接口人、团队 Leader 等多种发展方向供员工选择，并辅以提供相应的技术力、专业力、通用力、领导力等培训课程。奇舞团以开放和求贤的心态欢迎各种优秀人才关注和加入奇舞团。  

![](https://mmbiz.qpic.cn/mmbiz_png/cAd6ObKOzEBLicibtcprJISN18FgTtg2N1ichPnMqRhicrP20VfwnC4vday7gtEoiaSynIH1bas4N5kgicliakrLdtT2Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1#imgIndex=3)