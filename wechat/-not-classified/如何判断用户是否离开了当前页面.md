> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/YrtAVLQjp7Qee91vdm9R7g)

在现代 Web 应用中，了解用户何时离开或切换页面对于提升用户体验、保存未提交数据和分析用户行为至关重要。本文将全面探讨几种前端检测用户离开页面的方法及其应用场景。

核心方法
----

### 1. beforeunload 事件

`beforeunload`事件在窗口、文档或资源即将卸载时触发，允许开发者向用户显示确认离开的提示。

```
window.addEventListener('beforeunload', function (e) {  // 取消事件后，浏览器会提示用户确认是否离开  e.preventDefault();  // 需要设置returnValue才能在大多数浏览器中显示确认对话框  e.returnValue = '';});
```

**适用场景**：防止用户意外离开导致数据丢失。

**注意**：现代浏览器限制自定义提示消息，只能使用默认文本。

### 2. pagehide 事件

`pagehide`事件在会话历史记录中遍历到另一页面时触发，比`beforeunload`更可靠。

```
window.addEventListener('pagehide', function(event) {  // 执行清理操作或发送分析数据  console.log('页面被隐藏或卸载');});
```

### 3. visibilitychange 事件

当标签页的可见性发生变化时触发，适用于检测用户切换到其他标签页或最小化浏览器。

```
document.addEventListener('visibilitychange', function() {  if (document.visibilityState === 'hidden') {    console.log('页面不可见');    // 暂停视频、动画或发送分析数据  } else if (document.visibilityState === 'visible') {    console.log('页面可见');    // 恢复暂停的内容  }});
```

**适用场景**：优化资源使用，暂停不必要的后台活动。

### 4. mouseleave 事件

检测鼠标离开页面区域，适用于弹出式挽留窗口。

```
document.addEventListener('mouseleave', function(e) {  // 只有当鼠标从页面顶部离开时才触发  if (e.clientY <= 0) {    showExitIntentPopup();  }});
```

实际应用示例
------

下面是一个完整的示例，演示了如何实现用户离开检测功能：

```
<!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="UTF-8">    <meta >            <p>此页面演示了如何检测用户离开行为。尝试以下操作来查看效果：</p>            <ul>                <li>切换到其他浏览器标签</li>                <li>最小化浏览器窗口</li>                <li>关闭或刷新页面</li>                <li>将鼠标移动到浏览器顶部后移出窗口</li>            </ul>        </div>        <div class="controls">            <button id="toggleBeforeUnload">切换beforeunload保护</button>            <button id="clearLog">清除日志</button>        </div>        <h2>事件日志</h2>        <div class="event-log" id="eventLog"></div>    </div>    <script>        const eventLog = document.getElementById('eventLog');        const toggleBeforeUnloadBtn = document.getElementById('toggleBeforeUnload');        const clearLogBtn = document.getElementById('clearLog');                let beforeUnloadEnabled = false;        let beforeUnloadHandler = null;        // 添加日志条目        function addLogEntry(message) {            const now = newDate();            const timestamp = now.toTimeString().split(' ')[0];            const logEntry = document.createElement('div');            logEntry.className = 'event-item';            logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;            eventLog.appendChild(logEntry);            eventLog.scrollTop = eventLog.scrollHeight;        }        // 初始化事件监听        function initEventListeners() {            // beforeunload 事件            beforeUnloadHandler = function(e) {                addLogEntry('beforeunload事件触发 - 页面即将卸载');                e.preventDefault();                e.returnValue = '';            };            // pagehide 事件            window.addEventListener('pagehide', function() {                addLogEntry('pagehide事件触发 - 页面被隐藏');            });            // visibilitychange 事件            document.addEventListener('visibilitychange', function() {                if (document.visibilityState === 'hidden') {                    addLogEntry('visibilitychange事件触发 - 页面不可见');                } elseif (document.visibilityState === 'visible') {                    addLogEntry('visibilitychange事件触发 - 页面可见');                }            });            // mouseleave 事件 (仅当鼠标从顶部离开时)            document.addEventListener('mouseleave', function(e) {                if (e.clientY <= 0) {                    addLogEntry('mouseleave事件触发 - 鼠标离开页面');                    // 在实际应用中，这里可以显示退出弹窗                }            });            // 页面加载完成            addLogEntry('页面加载完成，开始监听用户离开行为');        }        // 切换beforeunload保护        function toggleBeforeUnload() {            if (beforeUnloadEnabled) {                window.removeEventListener('beforeunload', beforeUnloadHandler);                addLogEntry('已禁用beforeunload保护');                toggleBeforeUnloadBtn.textContent = '启用beforeunload保护';            } else {                window.addEventListener('beforeunload', beforeUnloadHandler);                addLogEntry('已启用beforeunload保护 - 尝试离开页面将显示确认对话框');                toggleBeforeUnloadBtn.textContent = '禁用beforeunload保护';            }            beforeUnloadEnabled = !beforeUnloadEnabled;        }        // 初始化        initEventListeners();        toggleBeforeUnloadBtn.addEventListener('click', toggleBeforeUnload);        clearLogBtn.addEventListener('click', function() {            eventLog.innerHTML = '';            addLogEntry('日志已清除');        });    </script></body></html>
```

最佳实践与注意事项
---------

1.  **谨慎使用 beforeunload**：过度使用确认离开对话框会损害用户体验，只在必要时使用。
    
2.  **性能考虑**：在 visibilitychange 事件中暂停不必要的任务可以节省资源。
    
3.  **数据保存**：定期保存用户数据到本地存储，而不是仅依赖离开事件。
    
4.  **浏览器兼容性**：虽然现代浏览器都支持这些 API，但要注意细微的差异。
    
5.  **移动端考虑**：移动设备上可能有不同的行为，需要充分测试。
    

结论
--

检测用户离开页面是提升 Web 应用用户体验的重要手段。通过合理使用 beforeunload、pagehide、visibilitychange 和 mouseleave 事件，开发者可以有效地管理用户离开时的行为，保护用户数据，并收集有价值的用户行为分析数据。

根据具体需求选择合适的方法，并始终以用户体验为中心，避免过度干扰用户的操作流程。