> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/6rLQXaAtL8Liy7LKyjT6lw)

前不久，Cursor 设计总监 Ryo Lu 在 X 上发布了若干最佳实践建议 (https://x.com/ryolu_/status/1914384195138511142)：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3xDuJ3eiciblkzmymjnPtgksDOtCqmUbnfQsm4jF5ia1zWph7dKz3Wc72w4GzRIaw5YbHtTfScAh2ic4zOxw0JicIXA/640?wx_fmt=png&from=appmsg)

内容基本匹配我的使用体感，工具始终是工具，即使如 Cursor，效果好坏最终还是取决于” 用的人 “

> 使用得当的 Cursor 可以让你写出快速、干净的代码；使用不当，它会生成让你清理一周的 AI 意大利面代码。

本文将围绕这一核心观点，结合实际经验，扩展聊聊 Ryo Lu 给出的建议。从项目规划到代码实现、从提示设计到错误修复，我们将逐条介绍正确用法、常见误区以及实战技巧。

整体而言，请将 Cursor 视作一个**强力但需要引导的初级工程师**：你提供清晰规范和持续指导，它才能发挥最大价值。

1.  设置 5-10 条清晰的项目规则（使用 `/generate rules` 命令）
---------------------------------------------

> **误区：**很多人刚上手 Cursor 时并不了解 Cursor Rules 规则，导致 AI 按默认设置自行发挥风格，导致 AI 输出代码风格前后不一致、偏离团队规范，非常影响效率

**正确用法：在项目之初创建一个精炼的 Cursor 规则文件（**`.cursor/rules`**），包含 5-10 条明确、可执行**的编码规范。这些规则可通过 Cursor 的命令如 `/Generate Cursor Rules` 生成初稿，再根据项目需要调整完善。内容上可以包括：

*   编码风格指南（例如 “使用 ESLint Standard 风格”）；
    
*   架构约定（如 “组件应为函数式组件”）；
    
*   依赖限定（如 “禁止使用未经批准的第三方库”）等。
    

规则既不要太多也不要模棱两可——就像团队的编码规范一样，**简明扼要，覆盖关键点**。

将规则文件放在 `.cursor/rules` 目录下，Cursor 会自动读取其中的约定来指导代码生成。例如，你的规则里规定 “所有接口请求必须使用封装的 `fetchClient` 库”，那么当你让 Cursor 生成接口调用代码时，它会遵循这个约定。不设置规则时，AI 可能随意使用 `axios` 或原生 `fetch` 导致不符合项目要求。如果规则过多或表述不清，也可以逐步调整：观察 AI 输出是否违背了某条约定，若是，优化规则表述或范围。

**将这些规则视作对新人开发者的指导手册**——简洁明确，让 Cursor 明白哪些行为是项目中 “允许” 或“禁止”的，从而减少后续返工。

2.  提示语要具体清晰，像写 Mini-Spec 一样明确技术栈和行为约束
--------------------------------------

> **误区：**很多工程师一开始给 Cursor 下达的指令（Prompt）过于笼统，例如：“帮我写一个登录页面”。这样模糊的提示常常导致 AI 输出偏离预期——可能生成旧式的 jQuery 代码，或忽略必要的错误处理。模棱两可的提示就好比给新人一个含糊的需求描述，结果对方各自发挥想象，产出不符合要求的代码。

**正确用法：编写提示语时要具体且清晰**，就像撰写一个小型技术规格说明（mini-spec）, 明确指出技术栈、需求细节和任何行为约束。例如，可以这样提示 Cursor：

```
使用 React 18 + TypeScript，实现一个登录表单组件。 要求： 1. 使用 Ant Design UI 库； 2. 包含用户名、密码两个字段和提交按钮； 3. 前端验证输入格式，错误信息用红色文本显示； 4. 按钮点击后调用 login(api) 接口，处理 loading 状态和错误提示； 5. 遵循我们团队的 ESLint 规则和文件结构。”
```

> 当然，这部分技术约束也可以用 `/Generate Cursor Rules` 指令生成到 rules 中。

这样的提示涵盖了**技术栈**（React 18 + TS、Ant Design）、**功能细节**（表单字段、验证、调用接口等）以及**行为约束**（团队 ESLint 规则、结构）。Cursor 在接到这样的明确指令后，就如同拿到了详细的产品需求和技术方案，生成的代码更有针对性。**总之，提示语越像规范书写，AI 输出就越精确**。

另外，建议在 Prompt 注明关键事项：框架版本、需遵守的模式（如 “使用 hooks 实现而非类组件”）、特殊边界情况处理等等。你也可以引用外部文档链接提供参考——例如使用某库时，在提示里附上官方文档链接，Cursor 会据此采用正确用法。

当提示涵盖足够上下文，AI 就不必胡乱猜测。如果**你发现输出不符合预期，应反思提示是否遗漏了关键细节，及时补充重试**。这种 “穷尽细节” 的提示思路就像资深工程师给新人写任务说明，确保对方按正确方向完成任务。

3.  按文件逐步推进，每次生成、测试、评审一个小目标
---------------------------

> **误区：**有人希望 Cursor 一步生成整个项目的代码结构或多个模块的实现，贪图省事一气呵成。现实是，一次性让 AI 产出大量代码，往往伴随结构混乱、错误难查的问题——就像让一个初级工程师一天之内写完整个应用，结果可想而知。大段未经检查的 AI 代码堆叠在一起，最终可能演变为需要花一周去梳理的 “AI 意大利面”。

**正确用法：**采用增量式、迭代式的方式推进开发节奏，每次**聚焦在一个小目标上，生成代码，立即测试和评审，然后再进行下一个目标**。

具体做法是按照功能或文件将项目拆解。例如，先创建项目骨架文件结构；接着让 AI 完成一个组件或一个模块；完成后运行测试或构建，检查是否有错误，再微调修复。每一步完成后，再进行下一步开发。通过这种逐步推进的方法，确保每个部分都经过验证再集成，减少后期大改的风险。

人类智能在应对开发任务时尚且需要做好技术方案、任务拆解、里程碑划定等，何况是 AI？因此，在实战**我们需要拥有模块化思维**，将具体任务拆解为若干复杂度适当的小任务。例如在开发一个 Web 页面时：

1.  先让 Cursor 生成布局框架（如路由、导航栏）；
    
2.  确认无误后，再让它处理某个页面的逻辑，如登录流程；
    
3.  然后再实现其它页面或组件。
    

每次只专注**一到两个文件**的改动，利用 Cursor 的上下文记忆保持风格一致。这样一来，**每个阶段输出的代码你都心中有数**。如果某一步 AI 产出了问题代码，范围也局限在最近修改的文件，更易于定位和修复。把 Cursor 当作新人时，这就相当于给 TA 分配一个个小任务，逐项完成、审核通过，再继续下一个，保证整体质量。

4.  所有 AI 输出都需人工审阅、手动修复，修复内容可作为学习示例反馈给 Cursor
---------------------------------------------

**误区：**相信 AI 会百分之百正确是一大误区。有人拿到 Cursor 输出的代码后不经检查就直接合入，结果引入隐蔽 bug 或性能问题；还有一种误区是完全依赖 AI 自我修正，比如发现错误就反复提示 Cursor “这里错了帮我改”，期待 AI 完美改好。但实际上，AI 并不了解自己输出的正确性，需要人工把关，而且不断地让 AI 猜你的反馈不如直接纠正来得高效。

**正确用法：**将 AI 输出视为初稿 或辅助结果，始终由人来审阅确认。拿到 Cursor 生成的代码后，逐行阅读和理解，就像在做 Code Review。一旦发现可疑之处或错误，优先选择手动修改来确保正确性。

实践中，不妨养成这样的习惯：**先信任但核实**。拿到 AI 代码后，运行本地构建或测试用例验证功能；若有报错或与预期不符，记录下问题。对于小问题直接改，大问题则考虑重新提示 AI。在反馈给 AI 时，语气友善但明确，指出问题原因和你的修复措施。这不仅提高后续结果质量，也帮助你加深对代码的理解。**切记：AI 给出的代码永远不应不经思考就直接投入生产**。正如带新人，任何新人写的代码也需要资深工程师审核后才能合并一样——Cursor 写的代码也必须经过你的审阅和调整才能算真正可用。

人工修复可以是修正算法、调整代码风格、添加遗漏的边界处理等。完成修复后，可以**将修改的内容和原因告诉 Cursor**，让 AI 学习改进。例如，你可以对 Cursor 说：“**刚才你生成的代码在处理空字符串时抛异常了，我将第 10 行改为… 来修复这个问题。今后遇到类似情况请注意****空值****检查。**” 通过这种反馈，Cursor 在同一会话的后续回答中会更注意类似问题，相当于对这个 “初级工程师” 进行现场指导。当然，也可以用 `/Generate Cursor Rules` 指令将错误信息整理为 Rules，实现长期记忆。

5.  使用 `@file`、`@folder`、`@git` 指令精确设定上下文范围
-------------------------------------------

**误区：**让 Cursor 在全局上下文下回答复杂问题或修改代码，容易出现答非所问或牵连过多的问题。如果不限定作用范围，AI 可能因为获取了过多无关信息而跑题，或者错误地修改了本不该动的代码。

例如，你只是想让 AI 修改 `utils.js` 中的一个函数，却没指定范围，Cursor 可能考虑到整个项目其他文件，结果给出一些全局性改动建议，增加混乱。

**正确用法：**Cursor 提供了 `@file`、`@folder`、`@git` 等指令用于在提示中嵌入特定范围的上下文，精确告诉 AI 聚焦在哪些内容上。正确使用这些指令可以大大提高 AI 回答的相关性：

*   **使用 @file**：将单个文件内容添加到提示上下文。例如在对话中输入 `@file path/to/utils.js`，Cursor 会读取该文件内容供 AI 参考。这样当你让 AI “重构这个文件的某函数” 时，它心里有数，只会基于提供的文件内容进行改写。
    
*   **使用 @folder**：将整个文件夹下的相关文件内容纳入上下文。这在涉及模块间交互时很有用，比如你要求 AI 修改组件 A 并相应更新组件 B，使用 `@folder components/` 可以让 AI 理解组件目录下的结构关系，再进行一致性修改。
    
*   **使用 @git**：将 Git 提交记录、差异（diff）或 Pull Request 内容提供给 AI。例如在让 Cursor 协助写提交信息或检查最近一次提交是否有遗漏时，使用 `@git diff` 或 `@git <commit_hash>` 能让 AI 聚焦在该次改动上进行分析。
    

实战中，每当你希望 AI 针对特定代码回答，先用 `@file` 或高亮选中代码片段再发问。这样 Cursor 几乎就像人在读那个文件然后回答你。如果需要让 AI 同时参考多个文件，可以多次使用 `@file`（注意上下文长度），或者提前把相关内容整合到一个临时笔记文件中一起嵌入。当修改范围较大时，考虑用 `@folder` 扫描整体。使用 `@git` 场景下，先做好 commit，再引用 diff 供 AI 审查或生成描述，这不仅让回复更准确也融入了版本控制流程。

总之，**精准设定上下文范围能让 Cursor 少走弯路，只专注你关心的部分**，避免 “牵一发动全身” 式的误操作。

6.  将设计文档和清单放入代码中，提供完整上下文
-------------------------

**误区**：很多时候，AI 之所以写出风马牛不相及的代码，是因为它不了解整个项目的大局。例如，你的项目有一份模块设计说明书或接口契约，但是 AI 并不直接知道；或者团队有特定的开发流程清单，但 AI 无从获知。如果我们每次提问都只说局部需求，而不让 Cursor 知道全局背景，那么 AI 就像闭门造车，代码与设计初衷南辕北辙。

**正确用法：善用 Cursor 提供的项目上下文功能，将总体设计和关键文档纳入** **AI** **上下文**。

具体而言，可以把**设计文档、需求说明、架构图解说明、开发检查清单**等资料放在项目的`.cursor/`目录下，这等价于在新人入项时，先给他一份完整的项目说明书参考：AI 清楚项目的背景和目标，自然能写出更贴合整体设计的代码。

比如，你在 `.cursor/` 下添加了文件 `design.md`，里面描述了系统的整体架构、模块职责，以及关键的数据结构。又例如放一个 `api-checklist.md`，列出每个接口在实现时都需要考虑的事项（参数验证、错误处理、日志等）。当 Cursor 知道这些信息后，你让它实现某个具体功能时，它会自动结合文档给出的指引。如果文档中注明 “模块 A 不直接调用数据库，而通过模块 B 提供的服务”，那么 AI 在实现模块 A 时就不会贸然写数据库查询，而会调用模块 B 的接口。这样就避免了偏离架构的实现。如果文档或清单较长，你也可以在对话中用 `@file .cursor/design.mdc` 明确引用相关部分，让 AI 聚焦关键段落。

总之，**提供完整上下文能极大提升** **AI** **理解正确性的上限**，别让 AI 闭眼造轮子，给它尽可能多的 “项目全景图”，它才能像一个有全局观的新成员一样工作。

7.  遇到错误代码，直接手写修复比长篇解释更快更有效
---------------------------

**误区：**当 Cursor 生成的代码出现错误时，一些用户倾向于反复和 AI 讨论错误、要求 AI 修复，希望 AI 自行悟出正确答案。然而这常常效率低下——Cursor 可能多次尝试仍未解决问题，或者曲解了你的提示。

毕竟 AI 对复杂 bug 的调试能力有限，与其苦口婆心地解释错误原因，不如直接更正代码来得干脆。把时间都花在教 AI 修 bug 上，往往得不偿失。

**正确用法：在发现** **AI** **输出的代码存在明显错误或设计缺陷时，优先考虑由你直接修改代码。**

人类智能通常能快速定位错误根源并给出修复方案，而 AI 有时会在错误的方向上越纠结越乱。这就像指导初级工程师：有些复杂问题你与其让新人试错，不如你示范解决一次，让他从中学习。在 Cursor 的场景中，你可以亲自编写修复后的代码，然后在下一次与 AI 交互时，把修改部分给它看，让它明白哪里修正了。

例如，Cursor 生成了一段算法但结果不正确。你调试后发现是某个边界条件处理不当。这时，与其对 Cursor 说 “大于多少的情况错了，请修复”，不如你直接修改代码（可能只需几行）确保正确运行。然后告诉 Cursor：“**我发现对于空数组输入你的实现返回了 undefined，所以我增加了一个判断返回空数组，修改如下…**”。这样一来，你立刻解决了问题，也把正确思路反馈给 Cursor。一些情况下，如果错误很多，你甚至可以暂停 AI 帮助，自己集中修改一轮，把代码整理好再继续使用 AI 辅助。

另外 Cursor 本身提供了 “Bug Finder” 之类的简单自动调试功能，但可靠度有限，人工介入往往必要。所以始终记住，**人是最后的保险**：当 AI 卡壳时，不妨亲自动手，用你的专业知识迅速扫清障碍，再让 Cursor 接棒继续其余简单工作。

8.  善用聊天记录进行迭代，而非每次重启 Prompt
----------------------------

**误区：**有些用户习惯遇到新问题就开启一个全新的对话或重新写提示，认为这样可以 “从头再来” 避免前文干扰。**实际上，频繁重置上下文会丢失宝贵的历史信息**：AI 不再记得先前你们确定的命名约定、讨论过的设计决策、前面生成的相关函数等等。相当于每次都换了一个新新人接手项目，新人对已有代码一无所知，必然重复走弯路甚至引入不一致的实现。

**正确用法：**应当充分利用 Cursor **对话的上下文记忆**能力，**在同一会话内持续迭代**。

也就是说，当完成一个阶段后，直接基于上一次对话继续提问或下达下一个任务，不要轻易清空上下文或开新窗口。Cursor 会保留之前的对话内容（在其上下文窗口容量范围内），包括你提供的文件、反馈的修改、既定的规则等。借助这些记忆，AI 在后续生成时会遵循先前的风格和约定，并能引用前面产生的代码片段。除非当前对话变得杂乱不堪或上下文长度超限，否则不要轻易 “推倒重来”。

举个例子，在一个连续的对话里，你先让 Cursor 创建了组件 A，然后下一步要求组件 B 与 A 交互。因为在同一会话中，Cursor **记得组件 A 的实现**和接口，它在写 B 时就能直接调用 A 的函数，而不需要你再次提供 A 的细节。这保证了组件 A 和 B 之间接口的一致性。又比如你之前规定了某变量命名风格（驼峰或下划线），AI 此时也会保持一致。如果中断上下文，新会话里 AI 可能又换另一种命名，让代码风格混杂。只有在不得已（比如长时间对话后模型开始遗忘早期内容）时，才考虑总结要点开启新对话，并在新对话开头把关键信息重新提供给 Cursor。

总之，把一次对话当作和同一个工程师持续合作：**时间越长他对项目理解越深，成果也就越契合**。

9.  有意识地选择模型
------------

**误区：**并非所有 AI 模型的风格和特长都相同。如果不加分辨一律使用默认模型，你可能错过更优的解题思路或更高效的配合方式。有的人全程只用某一个模型，结果在需要复杂推理的场景下效率低下，或者在要求精准代码的场景下得到了啰嗦且不可靠的输出。这就像带新人团队里只让一个人干所有事，即使他并不擅长某些任务。

**正确用法：了解并善用不同模型的特长**，根据任务类型选择最适合的 “AI 同事”。

例如，**Claude** 系列模型（如 Anthropic Claude 2）以**长上下文和推理见长**，在需要通识推理、总结长文档、提出方案思路时表现较好；而 **Gemini**（假设指类似 GPT-4 或未来的高精度模型）则在**代码准确性和严格执行**方面更胜一筹，适合生成要求精确符合规范的代码片段或复杂算法实现。另外，Cursor 支持的其它模型（如 GPT-4、GPT-3.5 等），也各有特点：GPT-4 综合能力强但可能速度较慢，3.5 速度快但需要更仔细验证结果。**根据任务灵活切换模型**，能达到事半功倍的效果。

实战中不妨按照任务来决定：

*   当你需要**脑暴 / 分析**时，选 Claude——比如 “请阅读这份大型需求文档并提炼关键点”，Claude 的长上下文优势可以一次看更多内容并给出条理分析；
    
*   当你需要**精工细作**写代码时，选 Gemini 或 GPT-4——比如 “实现一个二叉树的复杂算法并确保代码健壮”，这些模型往往遵循指令严格，代码准确率更高。
    

另外，你也可以组合使用：先用 Claude **讨论方案**、生成伪代码，确定思路后，再用 Gemini **详细实现**，最后用 GPT-4 **优化和润色**。这种组合拳能最大化发挥模型所长。当然，切换模型意味着上下文可能不共享，必要时在切换后重提供关键信息或文件内容，确保新模型接棒时了解当前进展。**将不同模型视作团队里不同专长的工程师，知人善任，才能让整个 “AI 团队” 高效协作**。

10.  对陌生技术栈：贴文档链接，逐行解释报错及修复逻辑
-----------------------------

**误区：**当涉及自己和 AI 都不熟悉的新技术、新框架时，一些人仍然直接让 Cursor 输出代码，结果往往问题百出——AI 可能调用不存在的函数或使用过时的用法，出现大量报错。如果这时仅靠 AI 自己去纠正，很可能陷入胡猜的死循环：AI 根据错误信息修一处又冒出新错，因为一开始对技术细节理解就不对。

缺乏资料和指导，等于让新人去摸一个没人教过的全新领域，碰壁是在所难免的。

**正确用法：当你让 Cursor 涉足一个陌生技术栈**时，要像导师带新人一样，**提前提供学习资料并一同分析错误**。

具体来说，在提示中**附上官方文档、教程链接或关键段落**，让 AI 先获取正确的背景知识。同时，当代码报错时，不要只丢给 AI 报错信息了事，应该**逐条解释错误含义并引导修复思路**。这种做法实际上是在跟 AI 做结对编程：你提供权威信息，AI 协助总结应用；你指出错误症结，AI 根据你的分析调整代码。通过你和 AI 的互动来共同攻克新技术。

例如，你第一次使用一个新的图表绘图库，Cursor 可能并不知道具体用法。如果直接让它写代码，编译可能通不过。这时，你可以在对话中**贴上该库的官方快速开始示例代码（或提供链接），并强调 “按照此文档使用该库”。**Cursor 获取这些信息后，再让它尝试编写，就会遵循文档示例格式，成功率大大提高。当出现错误提示（无论是编译错误还是运行异常），与其简单地对 AI 说 “报错了请修”，不如你先阅读错误信息，然后对 AI 解释：

```
错误提示指出模块找不到，也许是导入路径不对，我们需要调整为相对路径……
```

通过这种逐行分析错误日志的方式，AI 往往能更准确地定位问题并给出修复方案。同时你的解释过程也加深了自己对新技术的理解。一来一回，**你在扮演教练，AI 在配合修正**，最终顺利搞定以前没接触过的技术栈。

结语
--

把 Cursor 当作可重点培养的潜力新人。

综上所述，想要高效使用 Cursor 写出干净高效的代码，关键在于**方法和习惯**。我们讨论的这 12 条经验，从制定规则、清晰提问、小步迭代，到测试驱动、人工审查、范围限定，再到模型选择、知识补充以及大项目上下文管理，构成了一套**系统的使用策略**。贯穿始终的理念是：**将 Cursor 视作一个强力但需要引导的初级工程师**。你要做的就是像带新人一样带领它——给予规范和约束，让它明确任务边界；循序渐进分配工作，及时检查反馈；在需要时提供知识支持，必要时亲自上阵修正；针对不足耐心指导改进。

当你这样使用 Cursor 时，它将不只是一个代码生成工具，而会逐渐融入你的开发流程，成为值得信赖的 “AI 搭档”。正确使用能让它发挥惊人的效率优势，帮你快速产出高质量代码；而一旦方式不当，它也可能产出令人抓狂的混乱代码。有了上述指南，希望每一位前端工程师都能驾驭 Cursor 的威力，扬长避短，避免落入 AI 意大利面代码的陷阱，让 Cursor 真正成为团队中提效保质的一份子。今后，随着你不断总结和调整这些方法，与你的 AI 小伙伴配合也将越来越默契。

* * *

最后，我最近在整理一份关于 AI 辅助编程的知识库，期望完整覆盖从 Cursor 到 Agent 开发的内容，**打造全网最有价值的 Cursor 使用手册，实现 80% 编码替代率！**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3xDuJ3eiciblkzmymjnPtgksDOtCqmUbnfuPW0a4I1Qd4LTPtNHMW7TEEfibXa9yFzOPVMryJbpNtOPvPLvqzRXtg/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/3xDuJ3eiciblkzmymjnPtgksDOtCqmUbnf2XhZDLubf1OKruJewtaHxrCHlID7ofYcvGFJ21a4H7uEOeGu5aZSYA/640?wx_fmt=png&from=appmsg)

目前框架结构都梳理好了，但工作量超出预期，进度比较缓慢。。。感兴趣的同学可以到： https://ecn5ehmm9iou.feishu.cn/wiki/Wo2TwiNSZiRr8kkYoqmcXqYSnTg 看看，或者微信联系，多提建议：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/3xDuJ3eiciblkzmymjnPtgksDOtCqmUbnfSDusqtY6IsKFVBelzMFmPypkMhTf31SF0zhJQhyRv1UgpRL7qZXNyw/640?wx_fmt=png&from=appmsg)