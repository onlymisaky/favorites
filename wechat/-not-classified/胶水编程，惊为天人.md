> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/PpZulZQKvOcgsQm58tLqPA)

👀 看到胶水编程的概念，惊为天人。也确实 NB，只用 4 个字就把 Vibe Coding 技术选型的精髓说清楚了：能抄不写、能连不造、只用经过验证的模块

出自一个 4200+ Star 的开源项目，看了眼，最有价值的就是 README 里的这几句话

![](https://mmbiz.qpic.cn/sz_mmbiz_png/hM5HtkzgLYbDricFXXOOXW1NdNOhjktz0o0UEtGUkQ4t4siayib6pjOibOqdUGzP4KBeWjQVIfsHCQ6aklM2ibgu8Xg/640?wx_fmt=png&from=appmsg&watermark=1#imgIndex=0)

[《贾杰的 AI 编程秘籍》](https://mp.weixin.qq.com/s?__biz=MzIwMTM5MTM1NA==&mid=2649474437&idx=1&sn=4ae1516afc0ec71b7638dd79daaae2cb&scene=21#wechat_redirect)付费合集，共 10 篇，现已完结。30 元交个朋友，学不到真东西找我退钱；）

以及我的墨问合集《100 个思维碎片》，1 块钱 100 篇，与你探讨一些有意思的话题（文末有订阅方式

### 写在前面

这篇文章, 我们就来聊聊什么是 Vibe Coding, 以及它背后更牛逼的**胶水编程**思想。

### Vibe Coding 到底是什么?

#### 一句话理解

Vibe Coding 本质上就是: **用自然语言跟 AI 聊天, 让它帮你写代码, 你负责验证结果**。听起来很简单对吧? 但问题是, 如果你真的这么简单粗暴地用,**90% 的概率会翻车**。

为什么?

因为 AI 的自信远远超过了它的可靠性。它会一本正经地胡说八道, 生成看起来很专业、实际上漏洞百出的代码。更致命的是, 它**没有全局观**, 今天给你写一个功能, 明天再写另一个, 结果两段代码互相冲突, 架构一团糟。

#### 传统编程 vs Vibe Coding

我们来对比一下:

**传统编程**:

*   • 你: **人工**一行行敲代码
    
*   • 调试: 自己找 bug, 自己改
    
*   • 门槛: 必须懂语法、懂框架、懂最佳实践
    

**Vibe Coding(野生版)**:

*   • 你: 用自然语言描述需求
    
*   • AI: 生成代码
    
*   • 你: 复制粘贴, 能跑就行
    
*   • 问题:**AI 幻觉、代码混乱、技术债爆炸**
    

**Vibe Coding(正确版)**:

*   • 你: 用**精心设计的提示词**描述需求
    
*   • AI: 在**严格约束**下生成代码
    
*   • 你: **审查代码、验证结果、更新文档**
    
*   • 结果: 可维护、可迭代、可审计的代码库
    

看到区别了吗? 核心在于**规划驱动 + 上下文固定 + 模块化执行**。

### 核心理念: 规划就是一切

这是 Vibe Coding 最关键的一点, 没有之一。

#### 为什么不能让 AI 自主规划?

一定要记住: 绝不要让 AI 自主规划, 否则你的代码库会变成一团无法管理的乱麻。

想象一下, 你让一个没见过你家房子的人来装修。他今天改客厅, 明天动卧室, 后天又去拆厨房, 最后你会发现: **水电不通、承重墙被敲、门窗对不齐**。

AI 也是一样的。如果你不给它一个**清晰的蓝图**, 它就会:

*   • 今天生成一个 1000 行的巨型文件
    
*   • 明天又把逻辑拆到 20 个小文件里
    
*   • 后天发现之前的代码不对, 推翻重来
    

最后你得到的是一个**无法维护的巨石代码库**。

#### 正确的流程是什么?

Vibe Coding 的标准流程是这样的:

```
1. 需求 → 2. 上下文文档 → 3. 实施计划 → 4. 分步实现 → 5. 自测 → 6. 进度记录
```

每一步都要**人工把关**,AI 只是执行者, 不是决策者。

##### 第一步: 明确需求

不要说 "我想做一个游戏", 而要说:

*   • 这是一个**多人在线的飞行射击游戏**
    
*   • 玩家控制飞机, 可以**发射子弹**和**使用技能**
    
*   • 需要**实时同步**玩家位置
    
*   • 非目标: 不需要复杂的物理引擎、不需要单机模式
    

看到了吗? **一句话目标 + 非目标**, 这叫做明确边界。

##### 第二步: 生成上下文文档

把需求交给 AI, 让它生成三个核心文档:

1.  1. **游戏设计文档 (GDD)** 或 **产品需求文档 (PRD)**
    
2.  2. **技术栈选型** (tech-stack.md)
    
3.  3. **实施计划** (implementation-plan.md)
    

**关键**: 这些文档不是让 AI 自己写完就完事儿了, 而是要**你仔细审阅、修改、完善**, 确保它理解了你的意图。

##### 第三步: 设置 AI 规则

这一步**极其重要**, 却常常被忽略。

你必须设置强制规则, 让 AI 在生成任何代码前都阅读架构文档。比如:

```
# 重要提示(Always):# 写任何代码前必须完整阅读 memory-bank/@architecture.md# 写任何代码前必须完整阅读 memory-bank/@game-design-document.md# 每完成一个重大功能后,必须更新 memory-bank/@architecture.md
```

这些规则要设置为 **"Always"**(始终应用), 确保 AI 不会瞎搞。

##### 第四步: 分步执行

**永远不要**一次性让 AI 实现所有功能。正确的做法是:

```
第 1 步:搭建基础框架(验证通过) → Git 提交第 2 步:实现核心玩法(验证通过) → Git 提交  第 3 步:添加网络同步(验证通过) → Git 提交...
```

每完成一步, 必须:

1.  1. **验证结果** (跑测试、看效果)
    
2.  2. **提交 Git**(方便回滚)
    
3.  3. **更新进度文档** (progress.md)
    
4.  4. **新建会话** (清理 AI 的上下文)
    

### 胶水编程: 终极进化形态

好, 现在我们进入**最核心**的部分。

#### 什么是胶水编程?

传统编程是人写代码, Vibe Coding 是 AI 写代码人审代码, 而胶水编程是 AI 连接代码人审连接。

这是一个**根本性的转变**。我们不再让 AI **生成**代码 (这是 AI 幻觉的根源), 而是让它**连接**已有的成熟模块。

#### 为什么胶水编程是银弹?

传统的 Vibe Coding 有三大致命缺陷:

<table><thead><tr><th><section>问题</section></th><th><section>原因</section></th><th><section>胶水编程的解法</section></th></tr></thead><tbody><tr><td><section>🎭&nbsp;<strong>AI 幻觉</strong></section></td><td><section>AI 会编造不存在的 API</section></td><td><section>✅ 只使用已验证的成熟代码, 零幻觉</section></td></tr><tr><td><section>🧩&nbsp;<strong>复杂性爆炸</strong></section></td><td><section>从零写代码, bug 层出不穷</section></td><td><section>✅ 每个模块都是久经考验的轮子</section></td></tr><tr><td><section>🎓&nbsp;<strong>门槛过高</strong></section></td><td><section>需要懂很多技术细节</section></td><td><section>✅ 你只需要描述 "连接方式"</section></td></tr></tbody></table>

举个例子。假设你要做一个 "用户登录" 功能。

**传统 Vibe Coding**:

*   • 你: 让 AI 实现用户登录
    
*   • AI: 生成 200 行代码, 包括密码加密、Session 管理、数据库操作...
    
*   • 问题: 加密算法不安全、Session 逻辑有 bug、SQL 注入漏洞
    

**胶水编程**:

*   • 你: 用 Passport.js 做认证, 用 bcrypt 加密密码, 用 Redis 存 Session
    
*   • AI: 好的, 我把这三个成熟库连接起来
    
*   • 结果: **零 bug、生产级别的安全性、5 分钟搞定**
    

看到差别了吗? 不再让 AI 从零生成代码, 而是让它连接已有的成熟模块。

#### 胶水编程的核心原则

##### 1. 能抄不写

**永远先问 AI**:"有没有现成的库可以解决这个问题?"

不要重复造轮子。GitHub 上有几百万个开源项目, 99% 的需求都有现成的解决方案。

##### 2. 能连不造

把你的项目想象成**搭积木**:

*   • 用户认证 → Passport.js 这块积木
    
*   • 实时通信 → Socket.io 这块积木
    
*   • 数据库 → Prisma 这块积木
    

AI 的工作是把这些积木**粘合**起来, 而不是自己捏一个新积木。

##### 3. 只用经过验证的模块

判断一个库是否 "成熟", 看三个指标:

*   • **GitHub Star 数** (建议 10k+)
    
*   • **最近更新时间** (6 个月内有活跃维护)
    
*   • **文档完整度** (官方文档清晰详细)
    

#### 一个实际例子

假设你要做一个 "实时聊天应用"。

**传统方式 (AI 生成一切)**:

```
你 → AI: 帮我实现一个实时聊天AI → 生成: 2000 行 WebSocket 代码 + 自己实现的消息队列 + 自己写的数据库封装结果: bug 一堆,性能堪忧,无法扩展
```

**胶水方式**:

```
你 → AI: 我要用 Socket.io(实时通信) + Redis(消息队列) + MongoDB(数据存储)AI → 连接: Socket.io 连到 Express 服务器,Redis 做 pub/sub,MongoDB 存历史消息结果: 30 分钟搞定,生产级别的稳定性
```

**关键**: 你需要做的是:

1.  1. 找到合适的成熟库 (这一步可以让 AI 帮你搜索推荐)
    
2.  2. 让 AI 把它们连接起来
    
3.  3. 审查连接代码是否正确
    

### 工具链推荐

工欲善其事, 必先利其器。这里推荐一些**真正好用**的工具。

#### AI 模型选择

第一梯队: Claude Opus 4.5、gpt-5.1-codex.1-codex (xhigh)、Gemini 3.0 Pro

**建议**:

*   • 复杂项目用 **Claude Opus 4.5**(通过 Claude Code)
    
*   • 快速原型用 **Gemini 3.0 Pro**(免费额度充足)
    
*   • 本地开发用 **Ollama**(隐私优先)
    

#### 编辑器和终端

*   • **VSCode + Cursor**: 最流行的组合, 适合新手
    
*   • **Claude Code CLI**: 终端版 Claude, 适合命令行爱好者
    
*   • **Codex CLI**:OpenAI 的官方命令行工具
    
*   • **Neovim + LazyVim**: 键盘流的终极选择
    

P.S. 如果你想极致的 Vibe 体验, 装一个 Superwhisper, 用**语音**跟 AI 对话, 完全不用打字, 爽到飞起。

#### 必备的配套工具

*   • **tmux**: 终端复用, 多任务开发必备
    
*   • **Git**: 版本控制, 随时回滚
    
*   • **Mermaid Chart**: 把文字描述变成架构图
    
*   • **NotebookLM**: 用 AI 解读大型项目文档
    

### 实战技巧

#### 技巧 1: 短段落 + 高频提交

不要一次性让 AI 写几百行代码。正确的节奏是:

*   • **每次只改一个模块**
    
*   • **每 20-30 行代码就验证一次**
    
*   • **验证通过立刻 Git 提交**
    

为什么? 因为 AI 很容易**跑偏**, 小步快跑可以及时纠错。

#### 技巧 2: 清晰的约束条件

永远明确告诉 AI:

*   • **能改什么** (只改 api/ 目录下的代码)
    
*   • **不能改什么** (不许动 database/ 的迁移文件)
    

否则 AI 会 "好心办坏事", 把你好不容易搭好的架构改得面目全非。

#### 技巧 3:Debug 的正确姿势

遇到 bug 时, **不要**直接把整个项目丢给 AI。正确的做法是:

```
问题描述:- 预期: 点击按钮应该显示弹窗- 实际: 控制台报错 "Cannot read property 'show' of undefined"- 最小复现: 在 Home.tsx 的第 42 行点击 openModal 按钮相关代码:(只贴出问题相关的 10-20 行代码)
```

Debug 只给: 预期 vs 实际 + 最小复现。AI 最怕的就是信息过载, 你给它一堆无关代码, 它反而找不到重点。

#### 技巧 4: 定期切换会话

代码一多就切会话。为什么? 因为 AI 的上下文窗口是有限的, 聊得太久会 "失忆", 开始胡说八道。

建议: 每完成一个大功能, 就 `/clear` 或 `/new` 开启新对话, 同时让 AI 更新 progress.md 记录进度。

#### 技巧 5: 善用官方文档

一定要看官方文档, 先把官方文档爬下来喂给 AI。

AI 的训练数据可能过时, 或者对某个库理解不准确。但如果你把最新的官方文档喂给它, 它的输出质量会**飙升**。

方法:

```
你: 帮我用工具下载 Socket.io 的最新文档AI: (使用 wget 或 curl 下载)你: 现在基于这份文档帮我实现实时聊天
```

### 常见坑与血的教训

#### 坑 1: 盲目信任 AI

AI 的自信远远超过了它的可靠性。它会一本正经地告诉你:"这段代码绝对没问题", 然后你一跑就崩溃。

**教训**: 永远不要跳过测试环节, 哪怕是 AI 信誓旦旦保证的代码。

#### 坑 2: 不设置 Always 规则

如果你不设置强制规则, AI 会:

*   • 忘记项目架构
    
*   • 重复造轮子
    
*   • 生成风格不统一的代码
    

**教训**: 花 10 分钟设置好 CLAUDE.md 或 Agents.md, 能省掉后续几十个小时的返工。

#### 坑 3: 一次性实现所有功能

新手最爱犯的错误: 给 AI 一个超长需求列表, 希望它一次搞定。

结果: AI 生成了一个 5000 行的巨型文件, 里面 bug 无数, 你连从哪里开始改都不知道。

**教训**: 一次只做一件事。

#### 坑 4: 忽视版本控制

很多人嫌 Git 麻烦, 不提交就让 AI 继续写。结果 AI 一通瞎改, 想回滚都不知道回到哪个版本。

**教训**: 每完成一个小功能就 `git commit`, 写清楚提交信息。

### 进阶话题: 元方法论

如果你已经掌握了基础的 Vibe Coding, 可以尝试**元方法论**——让 AI 系统**自我优化**。

#### 核心思想

构建一个能够自我优化的 AI 系统, 通过递归迭代不断进化:

1.  1. **α- 提示词** (生成器): 专门生成其他提示词的 "母提示词"
    
2.  2. **Ω- 提示词** (优化器): 专门优化其他提示词的 "母提示词"
    

工作流程:

```
1. 用 AI 生成 α 和 Ω 的初始版本(v1)2. 用 Ω(v1) 优化 α(v1),得到 α(v2)3. 用 α(v2) 生成所有需要的目标提示词4. 循环往复,持续进化
```

这是一个**非常高级**的技巧, 建议在掌握基础流程后再尝试。

### 总结

好了, 我们来总结一下 Vibe Coding 的核心要点:

**道 (核心理念)**:

*   • 凡是 AI 能做的, 就不要人工做
    
*   • 目的主导, 一切动作围绕目标展开
    
*   • **规划驱动**, 绝不让 AI 自主规划
    
*   • 上下文是第一性要素, 垃圾进垃圾出
    

**法 (方法论)**:

*   • 一句话目标 + 非目标
    
*   • 能抄不写, 不重复造轮子
    
*   • 一定要看官方文档, 喂给 AI
    
*   • 接口先行, 实现后补
    

**术 (技巧)**:

*   • 明确写清: 能改什么, 不能改什么
    
*   • Debug 只给: 预期 vs 实际 + 最小复现
    
*   • 代码一多就切会话
    
*   • 定期 Git 提交
    

**器 (工具)**:

*   • Claude Opus 4.5 / gpt-5.1-codex.1-codex (xhigh)
    
*   • VSCode + Cursor / Claude Code CLI
    
*   • tmux + Git + Mermaid
    

最后, 再次强调: **胶水编程是 Vibe Coding 的终极形态**。不要让 AI 生成代码, 而是让它**连接**成熟的代码模块。这样可以:

*   • ✅ 消除 AI 幻觉
    
*   • ✅ 降低复杂度
    
*   • ✅ 提升可维护性
    

记住这个口诀: **能抄不写, 能连不造, 能复用不原创**。

### 参考资料

*   • Vibe Coding 中文指南
    
*   • Google Cloud: What is Vibe Coding
    
*   • 中科院 Vibe Coding 综述
    
*   • 火山引擎开发者社区: Vibe Coding 从入门到实践
    

P.S. 如果你觉得这篇文章对你有帮助, 不妨试试看用 Vibe Coding 的方式做一个小项目。别想太复杂, 就从一个 "待办事项清单" 或者 "天气查询应用" 开始, 体会一下这种全新的开发方式。

相信我, 一旦你掌握了诀窍, 你会发现: **编程从来没有这么爽过**。

 坚持创作不易，求个一键三连，谢谢你～❤️

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/hM5HtkzgLYavuT0httVEXU5P2UurAYUsicKSLSSKPZmiaqVaYWiaYlErmU6Pibs5uOHYxDkvuu8m2PNkuYEGIWrYiaw/640?wx_fmt=jpeg&from=appmsg&watermark=1#imgIndex=1)

以及「AI Coding 技术交流群」，联系 ayqywx 我拉你进群，共同交流学习～